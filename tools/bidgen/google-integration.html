<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- Favicon -->
<link rel="icon" href="/favicon.ico" sizes="16x16 32x32 48x48"/>
<link rel="icon" href="/favicon-32x32.png" sizes="32x32" type="image/png"/>
<link rel="icon" href="/favicon-96x96.png" sizes="96x96" type="image/png"/>
<link rel="icon" href="/android-chrome-192x192.png" sizes="192x192" type="image/png"/>
<link rel="apple-touch-icon" href="/apple-touch-icon.png" sizes="180x180"/>
<link rel="manifest" href="/manifest.json"/>
<meta name="msapplication-TileColor" content="#0A1D37"/>
<meta name="msapplication-TileImage" content="/ms-icon-144x144.png"/>
<meta name="theme-color" content="#0A1D37"/>
    <title>Google Integration Setup</title>
    <meta name="robots" content="noindex, nofollow">
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #1a1a2e; color: #eee; min-height: 100vh; }
        .container { max-width: 1200px; margin: 0 auto; padding: 30px 20px; }
        h1 { font-size: 28px; margin-bottom: 4px; color: #e8e8e8; }
        .subtitle { color: #7f8c8d; font-size: 14px; margin-bottom: 30px; }
        
        .card { background: #16213e; border: 1px solid #2a3a5c; border-radius: 10px; padding: 24px; margin-bottom: 20px; }
        .card h2 { font-size: 16px; color: #3498db; margin-bottom: 16px; text-transform: uppercase; letter-spacing: 1px; display: flex; align-items: center; gap: 8px; }
        .card h2 .icon { width: 28px; height: 28px; background: #3498db; color: white; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: bold; }
        
        .btn { padding: 14px 28px; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; display: inline-flex; align-items: center; gap: 8px; }
        .btn-primary { background: #3498db; color: white; }
        .btn-primary:hover { background: #2980b9; }
        .btn-success { background: #27ae60; color: white; }
        .btn-success:hover { background: #2ecc71; }
        .btn-warning { background: #f39c12; color: white; }
        .btn-warning:hover { background: #e67e22; }
        .btn-danger { background: #e74c3c; color: white; }
        .btn-danger:hover { background: #c0392b; }
        .btn-google { background: #4285f4; color: white; }
        .btn-google:hover { background: #3367d6; }
        
        .auth-section { text-align: center; padding: 40px; }
        .auth-section h3 { color: #3498db; margin-bottom: 20px; }
        .auth-status { margin-top: 20px; padding: 15px; background: #0f1a33; border-radius: 8px; }
        
        .service-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px; }
        .service-card { background: #0f1a33; border: 1px solid #2a3a5c; border-radius: 8px; padding: 20px; text-align: center; }
        .service-icon { font-size: 48px; margin-bottom: 15px; }
        .service-name { font-weight: 600; color: #3498db; margin-bottom: 10px; }
        .service-desc { font-size: 12px; color: #7f8c8d; margin-bottom: 15px; }
        .service-status { padding: 5px 10px; border-radius: 4px; font-size: 11px; font-weight: 600; }
        .status-connected { background: #27ae60; color: white; }
        .status-disconnected { background: #e74c3c; color: white; }
        .status-pending { background: #f39c12; color: white; }
        
        .scan-results { max-height: 300px; overflow-y: auto; margin-top: 15px; }
        .result-item { padding: 10px; margin-bottom: 5px; background: #0f1a33; border-radius: 6px; font-size: 12px; display: flex; justify-content: space-between; align-items: center; }
        .result-item.atp { border-left: 3px solid #e67e22; }
        .result-item.other { border-left: 3px solid #27ae60; }
        
        .progress-bar { width: 100%; height: 8px; background: #2a3a5c; border-radius: 4px; overflow: hidden; margin: 15px 0; }
        .progress-fill { height: 100%; background: #3498db; transition: width 0.3s; }
        
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin-top: 20px; }
        .stat-box { text-align: center; padding: 15px; background: #0f1a33; border-radius: 8px; border: 1px solid #2a3a5c; }
        .stat-value { font-size: 20px; font-weight: 700; color: #3498db; margin-bottom: 5px; }
        .stat-label { font-size: 10px; color: #7f8c8d; text-transform: uppercase; letter-spacing: 0.5px; }
        
        .notification { position: fixed; top: 20px; right: 20px; background: #3498db; color: white; padding: 15px 20px; border-radius: 8px; z-index: 10000; max-width: 350px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
    </style>
</head>
<body>

<div class="container">
    <h1>Google Integration Setup</h1>
    <p class="subtitle">Connect Google Drive and Gmail to automatically scan for ATP files</p>

    <!-- API KEY INPUT -->
    <div class="card" id="apiKeySection">
        <h2><span class="icon">üîë</span> Google API Key Required</h2>
        <div style="background: #0f1a33; border: 1px solid #f39c12; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
            <h4 style="color: #f39c12; margin-bottom: 10px;">üîí Security Notice</h4>
            <p style="font-size: 12px; color: #ecf0f1;">For security reasons, the Google API key is not stored in the code.</p>
            <p style="font-size: 12px; color: #ecf0f1;">You must provide your own API key to use Google services.</p>
        </div>
        
        <div style="margin-bottom: 20px;">
            <h4 style="color: #3498db; margin-bottom: 10px;">Steps to Get Your API Key:</h4>
            <ol style="font-size: 12px; color: #ecf0f1; margin-left: 20px; line-height: 1.6;">
                <li>Go to <a href="https://console.cloud.google.com/" target="_blank" style="color: #3498db;">Google Cloud Console</a></li>
                <li>Create a new project or select existing project</li>
                <li>Enable Google Drive API and Gmail API</li>
                <li>Go to Credentials ‚Üí Create Credentials ‚Üí API Key</li>
                <li>Restrict the key to your domains (recommended)</li>
                <li>Copy the API key and paste it below</li>
            </ol>
        </div>
        
        <div style="margin-bottom: 20px;">
            <label for="apiKeyInput" style="display: block; margin-bottom: 8px; color: #ecf0f1; font-weight: 600;">Enter Your Google API Key:</label>
            <input type="password" id="apiKeyInput" placeholder="AIzaSy..." style="width: 100%; padding: 12px; background: #0f1a33; border: 1px solid #2a3a5c; border-radius: 6px; color: #ecf0f1; font-size: 14px; margin-bottom: 15px;">
            <button class="btn btn-primary" onclick="saveApiKey()">üîë Save API Key</button>
        </div>
        
        <div style="background: #2a3a5c; border-radius: 8px; padding: 15px;">
            <h4 style="color: #f39c12; margin-bottom: 10px;">‚ö†Ô∏è Important Restrictions:</h4>
            <ul style="font-size: 11px; color: #ecf0f1; margin-left: 20px; line-height: 1.4;">
                <li>Add HTTP referrers: <code style="background: #1a1a2e; padding: 2px 4px; border-radius: 3px;">http://localhost:3000/*</code></li>
                <li>Add production referrers: <code style="background: #1a1a2e; padding: 2px 4px; border-radius: 3px;">https://wattsatpcontractor.com/*</code></li>
                <li>Restrict APIs: Google Drive API + Gmail API only</li>
                <li>Never share your API key publicly</li>
            </ul>
        </div>
    </div>

    <!-- API KEY INPUT -->
    <div class="card" id="apiKeyCard">
        <h2><span class="icon">üîë</span> API Key Required</h2>
        <div class="auth-section">
            <h3>Enter Your Google API Key</h3>
            <p style="color: #7f8c8d; margin-bottom: 20px;">Your API key was removed for security. Please enter it below to continue.</p>
            <div style="background: #0f1a33; border: 1px solid #f39c12; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                <h4 style="color: #f39c12; margin-bottom: 10px;">üîí Security Notice</h4>
                <p style="font-size: 12px; color: #ecf0f1;">Your API key is stored locally in your browser only.</p>
                <p style="font-size: 12px; color: #ecf0f1;">Never share your API key or commit it to public repositories.</p>
            </div>
            <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 15px;">
                <input type="password" id="apiKeyInput" placeholder="Enter your Google API key" style="flex: 1; padding: 10px; background: #0f1a33; border: 1px solid #2a3a5c; border-radius: 6px; color: #eee;">
                <button class="btn btn-primary" onclick="saveApiKey()">Save Key</button>
            </div>
            <div class="auth-status" id="apiKeyStatus">
                <p style="color: #7f8c8d;">API key required to continue</p>
            </div>
        </div>
    </div>

    <!-- AUTHENTICATION -->
    <div class="card" id="authCard" style="display: none;">
        <h2><span class="icon">üîê</span> Google Authentication</h2>
        <div class="auth-section">
            <h3>Connect Your Google Account</h3>
            <p style="color: #7f8c8d; margin-bottom: 20px;">Secure OAuth 2.0 authentication to access your Google Drive and Gmail</p>
            <div style="background: #0f1a33; border: 1px solid #f39c12; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                <h4 style="color: #f39c12; margin-bottom: 10px;">üîí Security Notice</h4>
                <p style="font-size: 12px; color: #ecf0f1;">This integration uses OAuth 2.0 with read-only permissions only. No files will be modified.</p>
                <p style="font-size: 12px; color: #ecf0f1;">All credentials are stored locally and never exposed publicly.</p>
            </div>
            <button class="btn btn-google" onclick="authenticateGoogle()">
                üîó Connect Google Account
            </button>
            <button class="btn btn-secondary" onclick="forceShowServices()" style="margin-left: 10px;">
                üîÑ Show Services (Debug)
            </button>
            <div class="auth-status" id="authStatus">
                <p style="color: #7f8c8d;">Not connected</p>
            </div>
        </div>
    </div>

    <!-- SERVICES -->
    <div class="card" id="servicesCard" style="display: none;">
        <h2><span class="icon">üìä</span> Connected Services</h2>
        <div class="service-grid">
            <div class="service-item">
                <div class="service-header">
                    <h3>üìÅ Google Drive</h3>
                    <p class="service-description">Scan Drive for ATP documents, quotes, and bids</p>
                    <div class="service-status" id="driveStatus">Not Connected</div>
                </div>
                <button class="btn btn-primary" onclick="scanDrive()">üîç Scan Drive</button>
            </div>
            <div class="service-item">
                <div class="service-header">
                    <h3>üìß Gmail</h3>
                    <p class="service-description">Scan emails for bid communications and attachments</p>
                    <div class="service-status" id="gmailStatus">Not Connected</div>
                </div>
                <button class="btn btn-primary" onclick="scanGmail()">üîç Scan Gmail</button>
            </div>
            <div class="service-item">
                <div class="service-header">
                    <h3>ÔøΩ Local Files</h3>
                    <p class="service-description">Scan local PC storage for quote files and historical bid data</p>
                    <div class="service-status" id="localStatus">Not Connected</div>
                </div>
                <input type="file" id="localFileInput" webkitdirectory directory multiple style="display: none;" onchange="handleLocalFileScan(event)">
                <button class="btn btn-primary" onclick="document.getElementById('localFileInput').click()">üìÅ Scan Local Files</button>
                <button class="btn btn-secondary" onclick="scanLocalQuotes()" style="margin-left: 10px;">üîç Auto-Scan Quotes</button>
                <button class="btn btn-danger" onclick="cancelLocalScan()" id="cancelScanBtn" style="margin-left: 10px; display: none;">üõë Cancel</button>
            </div>
            <div class="service-item">
                <div class="service-header">
                    <h3>ÔøΩüìä WSI Financials</h3>
                    <p class="service-description">Upload WSI financial spreadsheets for business intelligence</p>
                    <div class="service-status" id="financialsStatus">Not Connected</div>
                </div>
                <input type="file" id="financialsFileInput" multiple accept=".csv,.xlsx,.xls,.pdf" style="display: none;" onchange="handleFinancialsUpload(event)">
                <button class="btn btn-primary" onclick="document.getElementById('financialsFileInput').click()">üìä Upload Financials</button>
            </div>
            <div class="service-item">
                <div class="service-header">
                    <h3>üåä Wave Accounting</h3>
                    <p class="service-description">Upload Wave exports with receipt images and detailed transactions</p>
                    <div class="service-status" id="waveStatus">Not Connected</div>
                </div>
                <input type="file" id="waveFileInput" multiple accept=".csv,.xlsx,.xls,.pdf,.jpg,.jpeg,.png" style="display: none;" onchange="handleWaveUpload(event)">
                <button class="btn btn-primary" onclick="document.getElementById('waveFileInput').click()">ÔøΩ Upload Wave Files</button>
            </div>
        </div>
    </div>

    <!-- DATA FLOW MONITORING -->
    <div class="card" id="dataFlowCard" style="display: none;">
        <h2><span class="icon">üìä</span> Data Flow Monitor</h2>
        <div style="background: #0f1a33; border: 1px solid #3498db; border-radius: 8px; padding: 15px; margin-bottom: 15px;">
            <h4 style="color: #3498db; margin-bottom: 10px;">üîÑ Real-time Data Pipeline Status</h4>
            <div id="dataFlowStatus" style="font-size: 12px; color: #ecf0f1;">
                Initializing data flow monitoring...
            </div>
        </div>
        
        <div class="stats-grid">
            <div class="stat-box">
                <div class="stat-value" id="localScanned">0</div>
                <div class="stat-label">Local Files Scanned</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="localStorageCount">0</div>
                <div class="stat-label">LocalStorage Records</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="firebaseSynced">0</div>
                <div class="stat-label">Firebase Synced</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="bidGeneratorReady">0</div>
                <div class="stat-label">Bid Generator Ready</div>
            </div>
        </div>
        
        <div style="margin-top: 15px;">
            <h4 style="color: #3498db; margin-bottom: 10px;">üìã Data Transfer Log</h4>
            <div id="dataTransferLog" style="background: #0f1a33; border: 1px solid #2a3a5c; border-radius: 6px; padding: 10px; height: 200px; overflow-y: auto; font-size: 11px; color: #ecf0f1; font-family: monospace;">
                <!-- Data transfer events will appear here -->
            </div>
        </div>
        
        <div style="margin-top: 15px;">
            <button class="btn btn-primary" onclick="verifyDataFlow()">üîç Verify Data Flow</button>
            <button class="btn btn-secondary" onclick="testBidGeneratorSync()">üß™ Test Bid Generator Sync</button>
            <button class="btn btn-warning" onclick="exportDataFlowReport()">üìä Export Flow Report</button>
        </div>
    </div>

    <!-- SCAN RESULTS -->
    <div class="card" id="resultsCard" style="display: none;">
        <h2><span class="icon">üìã</span> Scan Results</h2>
        <div class="stats-grid">
            <div class="stat-box">
                <div class="stat-value" id="totalScanned">0</div>
                <div class="stat-label">Items Scanned</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="atpFound">0</div>
                <div class="stat-label">ATP Items</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="newBids">0</div>
                <div class="stat-label">New Bids</div>
            </div>
            <div class="stat-box">
                <div class="stat-value" id="imported">0</div>
                <div class="stat-label">Imported</div>
            </div>
        </div>
        
        <div class="scan-results" id="scanResults">
            <!-- Scan results will appear here -->
        </div>
        
        <div style="margin-top: 20px;">
            <button class="btn btn-success" onclick="importAllResults()">üöÄ Import All ATP Items</button>
            <button class="btn btn-warning" onclick="exportResults()">üìä Export Results</button>
        </div>
    </div>

    <!-- PROGRESS -->
    <div class="card" id="progressCard" style="display: none;">
        <h2><span class="icon">‚ö°</span> Scanning Progress</h2>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill" style="width: 0%;"></div>
        </div>
        <div id="progressText" style="margin-top: 10px; font-size: 12px; color: #7f8c8d;">Starting scan...</div>
    </div>
</div>

<script>
// =====================================================================
// FIREBASE INITIALIZATION (Same as bid generator)
// =====================================================================
const firebaseConfig = {
    apiKey: "YOUR_FIREBASE_API_KEY_HERE",
    authDomain: "wsi---bid-generator.firebaseapp.com",
    databaseURL: "https://wsi---bid-generator-default-rtdb.firebaseio.com",
    projectId: "wsi---bid-generator",
    storageBucket: "wsi---bid-generator.firebasestorage.app",
    messagingSenderId: "613129301141",
    appId: "1:613129301141:web:92405028eca5aae354bf9c",
    measurementId: "G-011LE4CZEF"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

// Save Google API key (for Drive/Gmail access, NOT Firebase)
function saveApiKey() {
    const apiKey = document.getElementById('apiKeyInput').value.trim();
    
    if (!apiKey) {
        document.getElementById('apiKeyStatus').innerHTML = '<p style="color: #e74c3c;">Please enter an API key</p>';
        return;
    }
    
    // Store Google API key in localStorage
    localStorage.setItem('google_api_key', apiKey);
    API_KEY = apiKey;
    
    // Show success and switch to auth card
    document.getElementById('apiKeyStatus').innerHTML = '<p style="color: #27ae60;">‚úì API key saved successfully</p>';
    document.getElementById('apiKeyCard').style.display = 'none';
    document.getElementById('authCard').style.display = 'block';
    
    // Initialize Google API with the provided key
    initGoogleApi();
}

// Utility function for hashing PIN
function hashPIN(pin) {
    let hash = 0;
    for (let i = 0; i < pin.length; i++) {
        const char = pin.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32-bit integer
    }
    return hash.toString();
}

// Google API Configuration
// SECURITY: All credentials are stored locally and never exposed to public
// Client ID is public information (safe to display)
// API Key is sensitive and should be provided by user
const CLIENT_ID = '1059217531358-84phisns4u8mt67v7g9aumksfqt69glj.apps.googleusercontent.com'; // Public identifier
let API_KEY = ''; // Sensitive - user must provide this

// OAuth 2.0 Scopes (read-only permissions only)
const SCOPES = [
    'https://www.googleapis.com/auth/drive.readonly',
    'https://www.googleapis.com/auth/gmail.readonly'
];

// Additional security measures
const SECURITY_CONFIG = {
    // Store tokens in localStorage (not in code)
    TOKEN_STORAGE_KEY: 'google_access_token',
    // Auto-refresh tokens before expiry
    TOKEN_REFRESH_BUFFER: 300000, // 5 minutes buffer
    // Clear tokens on logout
    CLEAR_ON_LOGOUT: true
};

// ATP detection patterns
const atpPatterns = [
    'atp', 'watts', 'justin watts', 'wsi', 'watts safety', 'bid', 'quote', 
    'estimate', 'contract', 'proposal', 'north park', 'allen', 'smith', 
    'kent', 'esperanza', 'pleasant', 'jayne'
];

let tokenClient;
let gapiInited = false;

// Load Google API key from localStorage
function loadApiKey() {
    const storedKey = localStorage.getItem('google_api_key');
    if (storedKey) {
        API_KEY = storedKey;
        document.getElementById('apiKeyInput').value = storedKey;
        document.getElementById('apiKeyCard').style.display = 'none';
        document.getElementById('authCard').style.display = 'block';
        return true;
    }
    return false;
}

// Initialize Google API (modern approach)
function initGoogleApi() {
    console.log('Initializing Google API with modern GIS...');
    
    if (!API_KEY) {
        showNotification('‚ùå API key not set. Please set your API key first.', 'error');
        return;
    }
    
    try {
        // Load Google API client library separately
        const script = document.createElement('script');
        script.src = 'https://apis.google.com/js/api.js';
        script.onload = () => {
            console.log('GAPI script loaded, initializing...');
            gapi.load('client', () => {
                console.log('GAPI client loaded, initializing...');
                
                gapi.client.init({
                    apiKey: API_KEY,
                    discoveryDocs: [
                        'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest',
                        'https://www.googleapis.com/discovery/v1/apis/gmail/v1/rest'
                    ]
                }).then(() => {
                    gapiInited = true;
                    console.log('‚úÖ Google API initialized successfully');
                    updateAuthStatus();
                    showNotification('‚úÖ Google API ready', 'success');
                }, (error) => {
                    console.error('‚ùå Error initializing Google API:', error);
                    console.error('Error details:', JSON.stringify(error, null, 2));
                    const errorMessage = error.error?.message || error.message || JSON.stringify(error);
                    showNotification(`‚ùå Google API Error: ${errorMessage}`, 'error');
                });
            });
        };
        document.head.appendChild(script);
        
    } catch (error) {
        console.error('‚ùå Failed to load GAPI:', error);
        showNotification('‚ùå Failed to load Google API library', 'error');
    }
}

// Initialize OAuth2 token client
function initTokenClient() {
    console.log('Initializing OAuth token client...');
    
    try {
        // Wait for Google Identity Services to load
        if (typeof google === 'undefined') {
            console.error('‚ùå Google Identity Services not loaded');
            showNotification('‚ùå Google Identity Services failed to load', 'error');
            return;
        }
        
        tokenClient = google.accounts.oauth2.initTokenClient({
            client_id: CLIENT_ID,
            scope: SCOPES.join(' '),
            callback: (tokenResponse) => {
                console.log('Token response received:', tokenResponse);
                if (tokenResponse && tokenResponse.access_token) {
                    console.log('Calling handleAuthSuccess...');
                    handleAuthSuccess(tokenResponse);
                } else {
                    showNotification('‚ùå Authentication failed - no token received', 'error');
                }
            }
        });
        console.log('‚úÖ Token client initialized');
    } catch (error) {
        console.error('‚ùå Failed to initialize token client:', error);
        showNotification('‚ùå Failed to initialize OAuth client', 'error');
    }
}

// Handle successful authentication
function handleAuthSuccess(tokenResponse) {
    console.log('handleAuthSuccess called with:', tokenResponse);
    
    // Store token securely
    localStorage.setItem(SECURITY_CONFIG.TOKEN_STORAGE_KEY, JSON.stringify(tokenResponse));
    
    // Update UI
    updateAuthStatus();
    showNotification('‚úÖ Successfully connected to Google account!', 'success');
    
    // Show the services card with scan buttons
    console.log('Showing services card...');
    const servicesCard = document.getElementById('servicesCard');
    if (servicesCard) {
        servicesCard.style.display = 'block';
        console.log('Services card displayed');
    } else {
        console.error('Services card not found!');
    }
    
    // Enable scan buttons
    const driveStatus = document.getElementById('driveStatus');
    const gmailStatus = document.getElementById('gmailStatus');
    const financialsStatus = document.getElementById('financialsStatus');
    const waveStatus = document.getElementById('waveStatus');
    
    if (driveStatus) {
        driveStatus.textContent = 'Connected';
        driveStatus.className = 'service-status status-connected';
    }
    
    if (gmailStatus) {
        gmailStatus.textContent = 'Connected';
        gmailStatus.className = 'service-status status-connected';
    }
    
    if (financialsStatus) {
        financialsStatus.textContent = 'Connected';
        financialsStatus.className = 'service-status status-connected';
    }
    
    if (waveStatus) {
        waveStatus.textContent = 'Connected';
        waveStatus.className = 'service-status status-connected';
    }
    
    console.log('Authentication success handling complete');
}

// Debug function to force show services
function forceShowServices() {
    console.log('Force showing services card...');
    const servicesCard = document.getElementById('servicesCard');
    if (servicesCard) {
        servicesCard.style.display = 'block';
        console.log('Services card forced to display');
        showNotification('üîÑ Services card forced to show (debug)', 'info');
    } else {
        console.error('Services card element not found!');
        showNotification('‚ùå Services card element not found!', 'error');
    }
}

// Update authentication status
function updateAuthStatus() {
    const token = localStorage.getItem(SECURITY_CONFIG.TOKEN_STORAGE_KEY);
    const authStatus = document.getElementById('authStatus');
    
    if (token) {
        authStatus.innerHTML = '‚úÖ Connected to Google account';
        authStatus.style.color = '#27ae60';
        
        // Show services card if already authenticated
        document.getElementById('servicesCard').style.display = 'block';
        
        // Update service statuses
        document.getElementById('driveStatus').textContent = 'Connected';
        document.getElementById('driveStatus').className = 'service-status status-connected';
        document.getElementById('gmailStatus').textContent = 'Connected';
        document.getElementById('gmailStatus').className = 'service-status status-connected';
    } else {
        authStatus.innerHTML = '‚ùå Not connected';
        authStatus.style.color = '#e74c3c';
        
        // Hide services card if not authenticated
        document.getElementById('servicesCard').style.display = 'none';
    }
}

// Authentication
function authenticateGoogle() {
    if (!tokenClient) {
        initTokenClient();
    }
    
    // Request OAuth token
    tokenClient.requestAccessToken();
}

// Show notification
function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.className = 'notification';
    notification.style.background = type === 'error' ? '#e74c3c' : type === 'success' ? '#27ae60' : '#3498db';
    notification.textContent = message;
    document.body.appendChild(notification);
    
    setTimeout(() => {
        notification.remove();
    }, 5000);
}


// Placeholder functions for scanning (to be implemented)
function scanDrive() {
    if (!gapiInited) {
        showNotification('‚ö†Ô∏è Google API not initialized', 'warning');
        return;
    }
    
    // Get OAuth token from localStorage
    const tokenData = localStorage.getItem(SECURITY_CONFIG.TOKEN_STORAGE_KEY);
    if (!tokenData) {
        showNotification('‚ö†Ô∏è Not authenticated. Please connect your Google account first.', 'warning');
        return;
    }
    
    try {
        const token = JSON.parse(tokenData);
        // Set the OAuth token for GAPI client
        gapi.client.setToken({
            access_token: token.access_token
        });
    } catch (error) {
        console.error('Error setting token:', error);
        showNotification('‚ùå Authentication error. Please reconnect your Google account.', 'error');
        return;
    }
    
    showNotification('üîç Scanning Google Drive for ATP files...', 'info');
    
    // Use broader search to avoid permission issues
    const searchQuery = "name contains 'bid' or name contains 'quote' or name contains 'atp' or name contains 'watts' or name contains 'contract' or name contains 'assistive' or name contains 'tech'";
    
    // Start with first batch
    scanDriveBatch(searchQuery, null, []);
}

// Function to scan Drive in batches to handle more files
function scanDriveBatch(searchQuery, pageToken, allFiles) {
    const requestParams = {
        q: searchQuery,
        fields: 'files(id, name, mimeType, size, modifiedTime, webViewLink), nextPageToken',
        pageSize: 100  // Maximum allowed per request
    };
    
    if (pageToken) {
        requestParams.pageToken = pageToken;
    }
    
    gapi.client.drive.files.list(requestParams).then(function(response) {
        const files = response.result.files || [];
        const nextPageToken = response.result.nextPageToken;
        
        if (files.length === 0 && !pageToken) {
            showNotification('üìÅ No ATP-related files found', 'info');
            return;
        }
        
        showNotification(`üìÅ Found ${files.length} files in this batch...`, 'info');
        
        // Add to all files collection
        allFiles = allFiles.concat(files);
        
        // Show progress
        showNotification(`üìÅ Processed ${allFiles.length} files so far...`, 'info');
        
        // Continue to next batch or finish
        if (nextPageToken && allFiles.length < 1000) { // Limit to 1000 to avoid infinite loops
            setTimeout(() => {
                scanDriveBatch(searchQuery, nextPageToken, allFiles);
            }, 500); // 500ms delay between batches
        } else {
            // Finished scanning
            finishDriveScan(allFiles, searchQuery);
        }
        
    }).catch(function(error) {
        console.error('Drive scan error:', error);
        showNotification('‚ùå Failed to scan Google Drive', 'error');
    });
}

// Finish Drive scan and show results
function finishDriveScan(allFiles, searchQuery) {
    const atpFiles = allFiles.filter(file => isATPFile(file.name));
    
    displayScanResults('drive', allFiles, atpFiles);
    
    // Analyze for predictive insights
    const predictiveAnalysis = analyzeDriveDataForPredictions(atpFiles);
    displayPredictiveAnalysis('drive', predictiveAnalysis);
    
    showNotification(`‚úÖ Drive scan complete: ${atpFiles.length} ATP files found out of ${allFiles.length} total`, 'success');
    
    // Update service status
    document.getElementById('driveStatus').textContent = `Connected (${atpFiles.length} files)`;
    document.getElementById('driveStatus').className = 'service-status status-connected';
}

function scanGmail() {
    if (!gapiInited) {
        showNotification('‚ö†Ô∏è Google API not initialized', 'warning');
        return;
    }
    
    // Get OAuth token from localStorage
    const tokenData = localStorage.getItem(SECURITY_CONFIG.TOKEN_STORAGE_KEY);
    if (!tokenData) {
        showNotification('‚ö†Ô∏è Not authenticated. Please connect your Google account first.', 'warning');
        return;
    }
    
    try {
        const token = JSON.parse(tokenData);
        // Set the OAuth token for GAPI client
        gapi.client.setToken({
            access_token: token.access_token
        });
    } catch (error) {
        console.error('Error setting token:', error);
        showNotification('‚ùå Authentication error. Please reconnect your Google account.', 'error');
        return;
    }
    
    showNotification('üîç Scanning Gmail for ATP-related emails...', 'info');
    
    // Use broader search to avoid permission issues
    const searchQuery = 'bid OR quote OR atp OR watts OR contract OR assistive OR tech OR (from:*.gov) OR (from:*.state.*.us)';
    
    // Start with first batch
    scanGmailBatch(searchQuery, null, []);
}

// Function to scan Gmail in batches to avoid rate limiting
function scanGmailBatch(searchQuery, pageToken, allEmails) {
    const requestParams = {
        userId: 'me',
        q: searchQuery,
        maxResults: 50  // Increased back to 50 for better coverage
    };
    
    if (pageToken) {
        requestParams.pageToken = pageToken;
    }
    
    gapi.client.gmail.users.messages.list(requestParams).then(function(response) {
        const messages = response.result.messages || [];
        const nextPageToken = response.result.nextPageToken;
        
        if (messages.length === 0 && !pageToken) {
            showNotification('üìß No ATP-related emails found', 'info');
            return;
        }
        
        showNotification(`üìß Found ${messages.length} emails in this batch...`, 'info');
        
        // Process this batch with rate limiting
        processGmailMessages(messages, allEmails, nextPageToken, searchQuery);
        
    }).catch(function(error) {
        console.error('Gmail scan error:', error);
        showNotification('‚ùå Failed to scan Gmail', 'error');
    });
}

// Process Gmail messages with rate limiting
function processGmailMessages(messages, allEmails, nextPageToken, searchQuery) {
    // Get message details with rate limiting
    const messagePromises = messages.map((message, index) => 
        new Promise((resolve) => {
            // Add delay to avoid rate limiting (429 errors)
            setTimeout(() => {
                gapi.client.gmail.users.messages.get({
                    userId: 'me',
                    id: message.id,
                    format: 'metadata',
                    metadataHeaders: ['Subject', 'From', 'Date', 'To']
                }).then(resolve).catch((error) => {
                    console.error(`Error fetching message ${message.id}:`, error);
                    resolve({ result: null, error: error });
                });
            }, index * 100); // Reduced to 100ms delay for faster processing
        })
    );
    
    Promise.all(messagePromises).then(function(messageDetails) {
        // Filter out failed requests and null results
        const validMessages = messageDetails
            .filter(detail => detail.result && !detail.error)
            .map(detail => detail.result);
        
        // Add to all emails collection
        allEmails = allEmails.concat(validMessages);
        
        // Show progress
        showNotification(`üìß Processed ${allEmails.length} emails so far...`, 'info');
        
        // Continue to next batch or finish
        if (nextPageToken && allEmails.length < 500) { // Limit to 500 to avoid infinite loops
            setTimeout(() => {
                scanGmailBatch(searchQuery, nextPageToken, allEmails);
            }, 1000); // 1 second delay between batches
        } else {
            // Finished scanning
            finishGmailScan(allEmails, searchQuery);
        }
    });
}

// Finish Gmail scan and show results
function finishGmailScan(allEmails, searchQuery) {
    const atpEmails = allEmails.filter(msg => isATPEmail(msg));
    
    displayScanResults('gmail', allEmails, atpEmails);
    
    // Analyze for predictive insights
    const predictiveAnalysis = analyzeGmailDataForPredictions(atpEmails);
    displayPredictiveAnalysis('gmail', predictiveAnalysis);
    
    showNotification(`‚úÖ Gmail scan complete: ${atpEmails.length} ATP emails found out of ${allEmails.length} total`, 'success');
    
    // Update service status
    document.getElementById('gmailStatus').textContent = `Connected (${atpEmails.length} emails)`;
    document.getElementById('gmailStatus').className = 'service-status status-connected';
}

// Analyze Drive data for predictive insights
function analyzeDriveDataForPredictions(atpFiles) {
    const analysis = {
        bidPatterns: {},
        clientTypes: {},
        serviceTypes: {},
        timePatterns: {},
        valueIndicators: {},
        recommendations: []
    };
    
    // Analyze file names for patterns
    atpFiles.forEach(file => {
        const name = file.name.toLowerCase();
        
        // Bid patterns
        if (name.includes('bid')) analysis.bidPatterns.bids = (analysis.bidPatterns.bids || 0) + 1;
        if (name.includes('quote')) analysis.bidPatterns.quotes = (analysis.bidPatterns.quotes || 0) + 1;
        if (name.includes('contract')) analysis.bidPatterns.contracts = (analysis.bidPatterns.contracts || 0) + 1;
        if (name.includes('proposal')) analysis.bidPatterns.proposals = (analysis.bidPatterns.proposals || 0) + 1;
        
        // Client types (from file names)
        if (name.includes('north park')) analysis.clientTypes['North Park'] = (analysis.clientTypes['North Park'] || 0) + 1;
        if (name.includes('allen')) analysis.clientTypes['Allen ISD'] = (analysis.clientTypes['Allen ISD'] || 0) + 1;
        if (name.includes('smith')) analysis.clientTypes['Smith ISD'] = (analysis.clientTypes['Smith ISD'] || 0) + 1;
        if (name.includes('kent')) analysis.clientTypes['Kent ISD'] = (analysis.clientTypes['Kent ISD'] || 0) + 1;
        if (name.includes('esperanza')) analysis.clientTypes['Esperanza'] = (analysis.clientTypes['Esperanza'] || 0) + 1;
        
        // Service types
        if (name.includes('assistive') || name.includes('atp')) analysis.serviceTypes['Assistive Technology'] = (analysis.serviceTypes['Assistive Technology'] || 0) + 1;
        if (name.includes('bathroom')) analysis.serviceTypes['Bathroom'] = (analysis.serviceTypes['Bathroom'] || 0) + 1;
        if (name.includes('kitchen')) analysis.serviceTypes['Kitchen'] = (analysis.serviceTypes['Kitchen'] || 0) + 1;
        if (name.includes('ramp')) analysis.serviceTypes['Ramp'] = (analysis.serviceTypes['Ramp'] || 0) + 1;
        
        // Time patterns (from modification dates)
        const modDate = new Date(file.modifiedTime);
        const month = modDate.toLocaleString('default', { month: 'long' });
        analysis.timePatterns[month] = (analysis.timePatterns[month] || 0) + 1;
        
        // Value indicators
        if (name.includes('large') || name.includes('major')) analysis.valueIndicators.highValue = (analysis.valueIndicators.highValue || 0) + 1;
        if (name.includes('small') || name.includes('minor')) analysis.valueIndicators.lowValue = (analysis.valueIndicators.lowValue || 0) + 1;
    });
    
    // Generate recommendations
    analysis.recommendations = generatePredictiveRecommendations(analysis);
    
    return analysis;
}

// Analyze Gmail data for predictive insights
function analyzeGmailDataForPredictions(atpEmails) {
    const analysis = {
        communicationPatterns: {},
        stateDomainActivity: {},
        responseTimes: {},
        bidOpportunities: {},
        recommendations: []
    };
    
    atpEmails.forEach(email => {
        const subject = (email.payload.headers.find(h => h.name === 'Subject')?.value || '').toLowerCase();
        const from = (email.payload.headers.find(h => h.name === 'From')?.value || '').toLowerCase();
        const date = new Date(email.payload.headers.find(h => h.name === 'Date')?.value || '');
        
        // Communication patterns
        if (subject.includes('bid')) analysis.communicationPatterns.bidDiscussions = (analysis.communicationPatterns.bidDiscussions || 0) + 1;
        if (subject.includes('quote')) analysis.communicationPatterns.quoteRequests = (analysis.communicationPatterns.quoteRequests || 0) + 1;
        if (subject.includes('meeting')) analysis.communicationPatterns.meetings = (analysis.communicationPatterns.meetings || 0) + 1;
        if (subject.includes('contract')) analysis.communicationPatterns.contractNegotiations = (analysis.communicationPatterns.contractNegotiations || 0) + 1;
        
        // State domain activity
        if (from.includes('.gov') || from.includes('.state.')) {
            const domain = from.split('@')[1];
            analysis.stateDomainActivity[domain] = (analysis.stateDomainActivity[domain] || 0) + 1;
        }
        
        // Time patterns
        const month = date.toLocaleString('default', { month: 'long' });
        analysis.responseTimes[month] = (analysis.responseTimes[month] || 0) + 1;
        
        // Bid opportunities
        if (subject.includes('rfp') || subject.includes('request for proposal')) {
            analysis.bidOpportunities.rfp = (analysis.bidOpportunities.rfp || 0) + 1;
        }
        if (subject.includes('invitation to bid')) {
            analysis.bidOpportunities.itb = (analysis.bidOpportunities.itb || 0) + 1;
        }
    });
    
    // Generate recommendations
    analysis.recommendations = generatePredictiveRecommendations(analysis);
    
    return analysis;
}

// Generate predictive recommendations
function generatePredictiveRecommendations(analysis) {
    const recommendations = [];
    
    // Drive-based recommendations
    if (analysis.bidPatterns && analysis.bidPatterns.bids > 5) {
        recommendations.push({
            type: 'opportunity',
            priority: 'high',
            title: 'High Bid Activity Detected',
            description: `Found ${analysis.bidPatterns.bids} bid documents - consider expanding bid submission capacity`,
            action: 'Review bid pipeline and allocate additional resources'
        });
    }
    
    if (analysis.clientTypes && Object.keys(analysis.clientTypes).length > 0) {
        const topClient = Object.entries(analysis.clientTypes).sort((a, b) => b[1] - a[1])[0];
        recommendations.push({
            type: 'insight',
            priority: 'medium',
            title: 'Top Client Identified',
            description: `${topClient[0]} has ${topClient[1]} documents - strong relationship opportunity`,
            action: 'Focus on deepening relationship with this client'
        });
    }
    
    if (analysis.serviceTypes && analysis.serviceTypes['Assistive Technology'] > 3) {
        recommendations.push({
            type: 'trend',
            priority: 'medium',
            title: 'ATP Services Trending',
            description: `High volume of ATP-related documents - growing market segment`,
            action: 'Consider expanding ATP service offerings and marketing'
        });
    }
    
    // Gmail-based recommendations
    if (analysis.stateDomainActivity && Object.keys(analysis.stateDomainActivity).length > 2) {
        recommendations.push({
            type: 'opportunity',
            priority: 'high',
            title: 'Multiple State Agencies Engaged',
            description: `Communications with ${Object.keys(analysis.stateDomainActivity).length} state domains - expansion opportunity`,
            action: 'Develop targeted outreach strategy for state agencies'
        });
    }
    
    if (analysis.bidOpportunities && (analysis.bidOpportunities.rfp > 0 || analysis.bidOpportunities.itb > 0)) {
        recommendations.push({
            type: 'action',
            priority: 'high',
            title: 'Active Bid Opportunities',
            description: `${(analysis.bidOpportunities.rfp || 0) + (analysis.bidOpportunities.itb || 0)} bid opportunities identified`,
            action: 'Prioritize responding to these opportunities immediately'
        });
    }
    
    return recommendations;
}

// Display predictive analysis
function displayPredictiveAnalysis(service, analysis) {
    const resultsContainer = document.getElementById('scanResults');
    
    // Create predictive analysis section
    const predictiveHTML = `
        <div class="predictive-analysis" style="background: #0f1a33; border: 1px solid #f39c12; border-radius: 10px; padding: 20px; margin-top: 20px;">
            <h3 style="color: #f39c12; margin-bottom: 15px;">üîÆ Predictive Analysis - ${service === 'drive' ? 'Google Drive' : 'Gmail'}</h3>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin-bottom: 20px;">
                ${generateAnalysisCards(analysis)}
            </div>
            
            <div style="margin-top: 20px;">
                <h4 style="color: #3498db; margin-bottom: 10px;">üéØ Predictive Recommendations</h4>
                ${generateRecommendationCards(analysis.recommendations)}
            </div>
            
            <div style="margin-top: 20px; text-align: center;">
                <button class="btn btn-success" onclick="exportPredictiveAnalysis('${service}')" style="margin-right: 10px;">üìä Export Analysis</button>
                <button class="btn btn-primary" onclick="applyPredictiveInsights()">üöÄ Apply to Bid Strategy</button>
            </div>
        </div>
    `;
    
    // Append to existing results
    resultsContainer.innerHTML += predictiveHTML;
}

// Generate analysis cards
function generateAnalysisCards(analysis) {
    let cards = '';
    
    // Bid patterns
    if (analysis.bidPatterns && Object.keys(analysis.bidPatterns).length > 0) {
        cards += `
            <div style="background: #1a2744; padding: 15px; border-radius: 8px;">
                <h5 style="color: #3498db; margin-bottom: 10px;">üìã Bid Patterns</h5>
                ${Object.entries(analysis.bidPatterns).map(([key, value]) => 
                    `<div style="font-size: 12px; color: #ecf0f1; margin-bottom: 5px;">${key}: ${value}</div>`
                ).join('')}
            </div>
        `;
    }
    
    // Client types
    if (analysis.clientTypes && Object.keys(analysis.clientTypes).length > 0) {
        cards += `
            <div style="background: #1a2744; padding: 15px; border-radius: 8px;">
                <h5 style="color: #3498db; margin-bottom: 10px;">üë• Client Types</h5>
                ${Object.entries(analysis.clientTypes).map(([client, count]) => 
                    `<div style="font-size: 12px; color: #ecf0f1; margin-bottom: 5px;">${client}: ${count} documents</div>`
                ).join('')}
            </div>
        `;
    }
    
    // Service types
    if (analysis.serviceTypes && Object.keys(analysis.serviceTypes).length > 0) {
        cards += `
            <div style="background: #1a2744; padding: 15px; border-radius: 8px;">
                <h5 style="color: #3498db; margin-bottom: 10px;">üîß Service Types</h5>
                ${Object.entries(analysis.serviceTypes).map(([service, count]) => 
                    `<div style="font-size: 12px; color: #ecf0f1; margin-bottom: 5px;">${service}: ${count}</div>`
                ).join('')}
            </div>
        `;
    }
    
    // State domain activity
    if (analysis.stateDomainActivity && Object.keys(analysis.stateDomainActivity).length > 0) {
        cards += `
            <div style="background: #1a2744; padding: 15px; border-radius: 8px;">
                <h5 style="color: #3498db; margin-bottom: 10px;">üèõÔ∏è State Domain Activity</h5>
                ${Object.entries(analysis.stateDomainActivity).map(([domain, count]) => 
                    `<div style="font-size: 12px; color: #ecf0f1; margin-bottom: 5px;">${domain}: ${count} emails</div>`
                ).join('')}
            </div>
        `;
    }
    
    return cards;
}

// Generate recommendation cards
function generateRecommendationCards(recommendations) {
    if (!recommendations || recommendations.length === 0) {
        return '<div style="color: #7f8c8d; font-style: italic;">No specific recommendations at this time.</div>';
    }
    
    return recommendations.map(rec => `
        <div style="background: ${rec.priority === 'high' ? '#2c3e50' : '#1a2744'}; border: 1px solid ${rec.type === 'opportunity' ? '#27ae60' : rec.type === 'action' ? '#e74c3c' : '#3498db'}; border-radius: 8px; padding: 15px; margin-bottom: 10px;">
            <div style="display: flex; align-items: center; margin-bottom: 8px;">
                <span style="background: ${rec.type === 'opportunity' ? '#27ae60' : rec.type === 'action' ? '#e74c3c' : '#3498db'}; color: white; padding: 4px 8px; border-radius: 12px; font-size: 10px; margin-right: 10px;">${rec.type.toUpperCase()}</span>
                <span style="background: ${rec.priority === 'high' ? '#e74c3c' : '#f39c12'}; color: white; padding: 4px 8px; border-radius: 12px; font-size: 10px;">${rec.priority.toUpperCase()}</span>
            </div>
            <h6 style="color: #ecf0f1; margin-bottom: 5px;">${rec.title}</h6>
            <p style="font-size: 12px; color: #bdc3c7; margin-bottom: 8px;">${rec.description}</p>
            <p style="font-size: 11px; color: #3498db; margin: 0;">üí° ${rec.action}</p>
        </div>
    `).join('');
}

// Export predictive analysis
function exportPredictiveAnalysis(service) {
    const analysis = window.scanResults && window.scanResults[service] ? window.scanResults[service].predictiveAnalysis : null;
    
    if (!analysis) {
        showNotification('‚ùå No analysis data available', 'error');
        return;
    }
    
    let reportText = `
========================================
PREDICTIVE ANALYSIS REPORT - ${service.toUpperCase()}
========================================

Analysis Date: ${new Date().toLocaleString()}
Data Source: ${service === 'drive' ? 'Google Drive Files' : 'Gmail Messages'}
Analysis Period: August 1, 2025 - Present

========================================
PREDICTIVE INSIGHTS
========================================

`;
    
    // Add analysis sections
    Object.keys(analysis).forEach(key => {
        if (key !== 'recommendations' && typeof analysis[key] === 'object') {
            reportText += `
${key.toUpperCase()}:
${Object.entries(analysis[key]).map(([k, v]) => `  ${k}: ${v}`).join('\n')}
`;
        }
    });
    
    reportText += `
========================================
PREDICTIVE RECOMMENDATIONS
========================================

${analysis.recommendations.map((rec, index) => `
${index + 1}. ${rec.title}
   Type: ${rec.type} | Priority: ${rec.priority}
   Description: ${rec.description}
   Action: ${rec.action}
`).join('\n')}

========================================
STRATEGIC IMPLICATIONS
========================================

This analysis provides data-driven insights for:
- Bid pipeline optimization
- Client relationship management
- Service offering adjustments
- Market expansion opportunities
- Resource allocation planning

========================================
END OF ANALYSIS
========================================
`;
    
    // Create and download the report
    const blob = new Blob([reportText], { type: 'text/plain' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `Predictive-Analysis-${service}-${new Date().toISOString().split('T')[0]}.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    window.URL.revokeObjectURL(url);
    
    showNotification(`üìä Predictive analysis exported for ${service}!`, 'success');
}

// Apply predictive insights to bid strategy
function applyPredictiveInsights() {
    showNotification('üöÄ Applying predictive insights to bid strategy...', 'info');
    
    // Save all scan results to Firebase for bid generator access
    if (window.scanResults && db) {
        const scanData = {
            results: window.scanResults,
            timestamp: new Date().getTime(),
            source: 'google_integration',
            version: '1.0'
        };
        
        // Save to Firebase under a shared path
        db.ref('shared/scanResults').set(scanData)
            .then(() => {
                showNotification('‚úÖ Intelligence data synced to cloud for bid generator!', 'success');
                
                // Also save to localStorage as backup
                localStorage.setItem('googleScanResults', JSON.stringify(window.scanResults));
                localStorage.setItem('lastGoogleScan', new Date().getTime().toString());
            })
            .catch(error => {
                console.error('Failed to save to Firebase:', error);
                showNotification('‚ö†Ô∏è Saved locally only (Firebase sync failed)', 'warning');
                
                // Fallback to localStorage
                localStorage.setItem('googleScanResults', JSON.stringify(window.scanResults));
                localStorage.setItem('lastGoogleScan', new Date().getTime().toString());
            });
    } else {
        showNotification('‚ùå No scan data available to apply', 'error');
    }
        
    // Auto-close if opened by bid generator
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('auto') === 'true') {
        setTimeout(() => {
            window.close();
        }, 2000);
    } else {
        // Open bid generator in new tab
        setTimeout(() => {
            window.open('dual-brand-bid-system.html', '_blank');
        }, 1000);
    }
}

// Auto-scan all sources when opened in auto mode
function autoScanAllSources() {
    console.log('üîÑ Starting auto-scan of all sources...');
    
    // Check if already authenticated
    const token = localStorage.getItem('google_access_token');
    if (!token) {
        console.log('‚ùå Not authenticated, cannot auto-scan');
        return;
    }
    
    // Auto-scan each source with delays
    setTimeout(() => scanDrive(), 1000);
    setTimeout(() => scanGmail(), 3000);
    setTimeout(() => {
        // Trigger file uploads for financials if needed
        showNotification('üìä Please upload WSI Financials files for complete analysis', 'info');
    }, 5000);
    setTimeout(() => {
        // Trigger file uploads for Wave if needed
        showNotification('üåä Please upload Wave Accounting files for complete analysis', 'info');
    }, 7000);
}


// Handle WSI Financials file upload
function handleFinancialsUpload(event) {
    const files = Array.from(event.target.files);
    
    if (files.length === 0) {
        showNotification('‚ùå No files selected', 'error');
        return;
    }
    
    showNotification(`üìä Processing ${files.length} WSI financial files...`, 'info');
    
    // Process uploaded files
    const financialFiles = files.map(file => ({
        id: 'local_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
        name: file.name,
        size: file.size,
        type: file.type,
        lastModified: new Date(file.lastModified).toISOString(),
        isLocal: true
    }));
    
    // Filter for WSI-related files
    const wsiFinancials = financialFiles.filter(file => isWSIFinancial(file.name));
    
    // Display results
    displayScanResults('financials', financialFiles, wsiFinancials);
    
    // Analyze for predictive insights
    const predictiveAnalysis = analyzeFinancialsForPredictions(wsiFinancials);
    displayPredictiveAnalysis('financials', predictiveAnalysis);
    
    // Update service status
    document.getElementById('financialsStatus').textContent = `Connected (${wsiFinancials.length} files)`;
    document.getElementById('financialsStatus').className = 'service-status status-connected';
    
    showNotification(`‚úÖ Financials upload complete: ${wsiFinancials.length} WSI files found out of ${files.length} total`, 'success');
}

// Handle Wave Accounting file upload
function handleWaveUpload(event) {
    const files = Array.from(event.target.files);
    
    if (files.length === 0) {
        showNotification('‚ùå No files selected', 'error');
        return;
    }
    
    showNotification(`üåä Processing ${files.length} Wave Accounting files...`, 'info');
    
    // Process uploaded files
    const waveFiles = files.map(file => ({
        id: 'local_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
        name: file.name,
        size: file.size,
        type: file.type,
        lastModified: new Date(file.lastModified).toISOString(),
        isLocal: true
    }));
    
    // Filter for Wave-related files
    const waveExports = waveFiles.filter(file => isWaveExport(file.name));
    
    // Display results
    displayScanResults('wave', waveFiles, waveExports);
    
    // Analyze for predictive insights
    const predictiveAnalysis = analyzeWaveDataForPredictions(waveExports);
    displayPredictiveAnalysis('wave', predictiveAnalysis);
    
    // Update service status
    document.getElementById('waveStatus').textContent = `Connected (${waveExports.length} files)`;
    document.getElementById('waveStatus').className = 'service-status status-connected';
    
    showNotification(`‚úÖ Wave upload complete: ${waveExports.length} Wave files found out of ${files.length} total`, 'success');
}

// Scan WSI Financials for business intelligence
function scanFinancials() {
    if (!gapiInited) {
        showNotification('‚ö†Ô∏è Google API not initialized', 'warning');
        return;
    }
    
    showNotification('üìä Scanning WSI Financial spreadsheets...', 'info');
    
    // Use broader search to avoid permission issues
    const searchQuery = "name contains 'wsi' or name contains 'financial' or name contains 'receipt' or name contains 'invoice' or name contains 'job' or name contains 'cost' or name contains 'expense' or name contains 'profit' or name contains 'revenue'";
    
    // Start with first batch
    scanFinancialsBatch(searchQuery, null, []);
}

// Function to scan financials in batches
function scanFinancialsBatch(searchQuery, pageToken, allFinancials) {
    const requestParams = {
        q: searchQuery,
        fields: 'files(id, name, mimeType, size, modifiedTime, webViewLink), nextPageToken',
        pageSize: 100
    };
    
    if (pageToken) {
        requestParams.pageToken = pageToken;
    }
    
    gapi.client.drive.files.list(requestParams).then(function(response) {
        const files = response.result.files || [];
        const nextPageToken = response.result.nextPageToken;
        
        if (files.length === 0 && !pageToken) {
            showNotification('üìä No WSI financial files found', 'info');
            return;
        }
        
        showNotification(`üìä Found ${files.length} financial files in this batch...`, 'info');
        
        // Add to all financials collection
        allFinancials = allFinancials.concat(files);
        
        // Show progress
        showNotification(`üìä Processed ${allFinancials.length} financial files so far...`, 'info');
        
        // Continue to next batch or finish
        if (nextPageToken && allFinancials.length < 500) {
            setTimeout(() => {
                scanFinancialsBatch(searchQuery, nextPageToken, allFinancials);
            }, 500);
        } else {
            // Finished scanning
            finishFinancialsScan(allFinancials, searchQuery);
        }
        
    }).catch(function(error) {
        console.error('Financials scan error:', error);
        showNotification('‚ùå Failed to scan WSI Financials', 'error');
    });
}

// Finish financials scan and show results
function finishFinancialsScan(allFinancials, searchQuery) {
    const wsiFinancials = allFinancials.filter(file => isWSIFinancial(file.name));
    
    displayScanResults('financials', allFinancials, wsiFinancials);
    
    // Analyze for predictive insights
    const predictiveAnalysis = analyzeFinancialsForPredictions(wsiFinancials);
    displayPredictiveAnalysis('financials', predictiveAnalysis);
    
    showNotification(`‚úÖ Financials scan complete: ${wsiFinancials.length} WSI financial files found out of ${allFinancials.length} total`, 'success');
    
    // Update service status
    document.getElementById('financialsStatus').textContent = `Connected (${wsiFinancials.length} files)`;
    document.getElementById('financialsStatus').className = 'service-status status-connected';
}

// Check if file is WSI financial-related
function isWSIFinancial(filename) {
    const financialPatterns = [
        'wsi', 'watts safety', 'financial', 'receipt', 'invoice', 'job', 'cost', 
        'expense', 'profit', 'revenue', 'budget', 'payroll', 'material', 'labor',
        'bid cost', 'project cost', 'overhead', 'margin', 'markup'
    ];
    
    const lowerFilename = filename.toLowerCase();
    return financialPatterns.some(pattern => lowerFilename.includes(pattern.toLowerCase()));
}

// Analyze financials data for predictive insights
function analyzeFinancialsForPredictions(financialFiles) {
    const analysis = {
        financialPatterns: {},
        jobTypes: {},
        costCategories: {},
        profitMargins: {},
        revenueTrends: {},
        recommendations: []
    };
    
    // Analyze file names for financial patterns
    financialFiles.forEach(file => {
        const name = file.name.toLowerCase();
        
        // Financial document types
        if (name.includes('receipt')) analysis.financialPatterns.receipts = (analysis.financialPatterns.receipts || 0) + 1;
        if (name.includes('invoice')) analysis.financialPatterns.invoices = (analysis.financialPatterns.invoices || 0) + 1;
        if (name.includes('expense')) analysis.financialPatterns.expenses = (analysis.financialPatterns.expenses || 0) + 1;
        if (name.includes('profit')) analysis.financialPatterns.profitReports = (analysis.financialPatterns.profitReports || 0) + 1;
        if (name.includes('revenue')) analysis.financialPatterns.revenueReports = (analysis.financialPatterns.revenueReports || 0) + 1;
        
        // Job types
        if (name.includes('bathroom')) analysis.jobTypes.bathroom = (analysis.jobTypes.bathroom || 0) + 1;
        if (name.includes('kitchen')) analysis.jobTypes.kitchen = (analysis.jobTypes.kitchen || 0) + 1;
        if (name.includes('ramp')) analysis.jobTypes.ramp = (analysis.jobTypes.ramp || 0) + 1;
        if (name.includes('lift')) analysis.jobTypes.lift = (analysis.jobTypes.lift || 0) + 1;
        if (name.includes('assistive')) analysis.jobTypes.assistiveTech = (analysis.jobTypes.assistiveTech || 0) + 1;
        
        // Cost categories
        if (name.includes('material')) analysis.costCategories.materials = (analysis.costCategories.materials || 0) + 1;
        if (name.includes('labor')) analysis.costCategories.labor = (analysis.costCategories.labor || 0) + 1;
        if (name.includes('overhead')) analysis.costCategories.overhead = (analysis.costCategories.overhead || 0) + 1;
        if (name.includes('equipment')) analysis.costCategories.equipment = (analysis.costCategories.equipment || 0) + 1;
        
        // Profit indicators
        if (name.includes('margin') || name.includes('markup')) analysis.profitMargins.highMargin = (analysis.profitMargins.highMargin || 0) + 1;
        if (name.includes('loss') || name.includes('deficit')) analysis.profitMargins.lowMargin = (analysis.profitMargins.lowMargin || 0) + 1;
        
        // Time patterns (from modification dates)
        const modDate = new Date(file.modifiedTime);
        const month = modDate.toLocaleString('default', { month: 'long' });
        analysis.revenueTrends[month] = (analysis.revenueTrends[month] || 0) + 1;
    });
    
    // Generate recommendations
    analysis.recommendations = generateFinancialRecommendations(analysis);
    
    return analysis;
}

// Generate financial recommendations
function generateFinancialRecommendations(analysis) {
    const recommendations = [];
    
    // High volume recommendations
    if (analysis.financialPatterns.receipts > 20) {
        recommendations.push({
            type: 'insight',
            priority: 'medium',
            title: 'High Receipt Volume',
            description: `Found ${analysis.financialPatterns.receipts} receipt files - consider automated expense tracking`,
            action: 'Implement digital receipt management system'
        });
    }
    
    if (analysis.jobTypes.bathroom > 5) {
        recommendations.push({
            type: 'opportunity',
            priority: 'high',
            title: 'Bathroom Jobs Trending',
            description: `${analysis.jobTypes.bathroom} bathroom-related financial files - strong market segment`,
            action: 'Focus marketing on bathroom accessibility services'
        });
    }
    
    if (analysis.costCategories.materials > 10) {
        recommendations.push({
            type: 'trend',
            priority: 'medium',
            title: 'Material Cost Tracking',
            description: `High volume of material cost tracking - good cost control practices`,
            action: 'Consider bulk purchasing discounts for common materials'
        });
    }
    
    if (analysis.profitMargins.lowMargin > 2) {
        recommendations.push({
            type: 'action',
            priority: 'high',
            title: 'Margin Concerns Detected',
            description: `${analysis.profitMargins.lowMargin} files indicate margin issues - review pricing strategy`,
            action: 'Analyze low-margin projects and adjust pricing models'
        });
    }
    
    if (analysis.revenueTrends && Object.keys(analysis.revenueTrends).length > 0) {
        const topMonth = Object.entries(analysis.revenueTrends).sort((a, b) => b[1] - a[1])[0];
        recommendations.push({
            type: 'insight',
            priority: 'medium',
            title: 'Peak Business Month',
            description: `${topMonth[0]} shows highest activity - seasonal pattern detected`,
            action: 'Plan resource allocation around peak business periods'
        });
    }
    
    return recommendations;
}

// Scan Wave Accounting exports for detailed financial intelligence
function scanWaveAccounting() {
    if (!gapiInited) {
        showNotification('‚ö†Ô∏è Google API not initialized', 'warning');
        return;
    }
    
    showNotification('üåä Scanning Wave Accounting exports...', 'info');
    
    // Use broader search to avoid permission issues
    const searchQuery = "name contains 'wave' or name contains 'accounting' or name contains 'export' or name contains 'transaction' or name contains 'receipt' or name contains 'invoice' or name contains 'csv' or name contains 'xlsx' or name contains 'journal'";
    
    // Start with first batch
    scanWaveBatch(searchQuery, null, []);
}

// Function to scan Wave files in batches
function scanWaveBatch(searchQuery, pageToken, allWaveFiles) {
    const requestParams = {
        q: searchQuery,
        fields: 'files(id, name, mimeType, size, modifiedTime, webViewLink), nextPageToken',
        pageSize: 100
    };
    
    if (pageToken) {
        requestParams.pageToken = pageToken;
    }
    
    gapi.client.drive.files.list(requestParams).then(function(response) {
        const files = response.result.files || [];
        const nextPageToken = response.result.nextPageToken;
        
        if (files.length === 0 && !pageToken) {
            showNotification('üåä No Wave Accounting files found', 'info');
            return;
        }
        
        showNotification(`üåä Found ${files.length} Wave files in this batch...`, 'info');
        
        // Add to all Wave files collection
        allWaveFiles = allWaveFiles.concat(files);
        
        // Show progress
        showNotification(`üåä Processed ${allWaveFiles.length} Wave files so far...`, 'info');
        
        // Continue to next batch or finish
        if (nextPageToken && allWaveFiles.length < 500) {
            setTimeout(() => {
                scanWaveBatch(searchQuery, nextPageToken, allWaveFiles);
            }, 500);
        } else {
            // Finished scanning
            finishWaveScan(allWaveFiles, searchQuery);
        }
        
    }).catch(function(error) {
        console.error('Wave scan error:', error);
        showNotification('‚ùå Failed to scan Wave Accounting', 'error');
    });
}

// Finish Wave scan and show results
function finishWaveScan(allWaveFiles, searchQuery) {
    const waveExports = allWaveFiles.filter(file => isWaveExport(file.name));
    
    displayScanResults('wave', allWaveFiles, waveExports);
    
    // Analyze for predictive insights
    const predictiveAnalysis = analyzeWaveDataForPredictions(waveExports);
    displayPredictiveAnalysis('wave', predictiveAnalysis);
    
    showNotification(`‚úÖ Wave scan complete: ${waveExports.length} Wave export files found out of ${allWaveFiles.length} total`, 'success');
    
    // Update service status
    document.getElementById('waveStatus').textContent = `Connected (${waveExports.length} files)`;
    document.getElementById('waveStatus').className = 'service-status status-connected';
}

// Check if file is Wave Accounting export
function isWaveExport(filename) {
    const wavePatterns = [
        'wave', 'accounting', 'export', 'transaction', 'receipt', 'invoice', 
        'csv', 'xlsx', 'journal', 'ledger', 'trial balance', 'profit & loss',
        'balance sheet', 'cash flow', 'accounts payable', 'accounts receivable',
        'expense report', 'vendor', 'customer', 'payment'
    ];
    
    const lowerFilename = filename.toLowerCase();
    return wavePatterns.some(pattern => lowerFilename.includes(pattern.toLowerCase()));
}

// Analyze Wave data for predictive insights
function analyzeWaveDataForPredictions(waveFiles) {
    const analysis = {
        transactionTypes: {},
        expenseCategories: {},
        incomeSources: {},
        vendorPatterns: {},
        customerPatterns: {},
        receiptActivity: {},
        cashFlow: {},
        recommendations: []
    };
    
    // Analyze file names for Wave patterns
    waveFiles.forEach(file => {
        const name = file.name.toLowerCase();
        
        // Transaction types
        if (name.includes('invoice')) analysis.transactionTypes.invoices = (analysis.transactionTypes.invoices || 0) + 1;
        if (name.includes('receipt')) analysis.transactionTypes.receipts = (analysis.transactionTypes.receipts || 0) + 1;
        if (name.includes('payment')) analysis.transactionTypes.payments = (analysis.transactionTypes.payments || 0) + 1;
        if (name.includes('expense')) analysis.transactionTypes.expenses = (analysis.transactionTypes.expenses || 0) + 1;
        if (name.includes('journal')) analysis.transactionTypes.journal = (analysis.transactionTypes.journal || 0) + 1;
        
        // Expense categories
        if (name.includes('material')) analysis.expenseCategories.materials = (analysis.expenseCategories.materials || 0) + 1;
        if (name.includes('labor')) analysis.expenseCategories.labor = (analysis.expenseCategories.labor || 0) + 1;
        if (name.includes('equipment')) analysis.expenseCategories.equipment = (analysis.expenseCategories.equipment || 0) + 1;
        if (name.includes('travel')) analysis.expenseCategories.travel = (analysis.expenseCategories.travel || 0) + 1;
        if (name.includes('office')) analysis.expenseCategories.office = (analysis.expenseCategories.office || 0) + 1;
        
        // Income sources
        if (name.includes('customer')) analysis.incomeSources.customers = (analysis.incomeSources.customers || 0) + 1;
        if (name.includes('client')) analysis.incomeSources.clients = (analysis.incomeSources.clients || 0) + 1;
        if (name.includes('project')) analysis.incomeSources.projects = (analysis.incomeSources.projects || 0) + 1;
        
        // Vendor patterns
        if (name.includes('vendor')) analysis.vendorPatterns.suppliers = (analysis.vendorPatterns.suppliers || 0) + 1;
        if (name.includes('supplier')) analysis.vendorPatterns.suppliers = (analysis.vendorPatterns.suppliers || 0) + 1;
        if (name.includes('contractor')) analysis.vendorPatterns.contractors = (analysis.vendorPatterns.contractors || 0) + 1;
        
        // Receipt activity (indicates expense tracking quality)
        if (name.includes('receipt')) analysis.receiptActivity.highTracking = (analysis.receiptActivity.highTracking || 0) + 1;
        if (name.includes('expense report')) analysis.receiptActivity.detailedReporting = (analysis.receiptActivity.detailedReporting || 0) + 1;
        
        // Cash flow indicators
        if (name.includes('cash flow')) analysis.cashFlow.reports = (analysis.cashFlow.reports || 0) + 1;
        if (name.includes('balance sheet')) analysis.cashFlow.balanceSheets = (analysis.cashFlow.balanceSheets || 0) + 1;
        if (name.includes('profit & loss')) analysis.cashFlow.profitLoss = (analysis.cashFlow.profitLoss || 0) + 1;
        
        // Time patterns (from modification dates)
        const modDate = new Date(file.modifiedTime);
        const month = modDate.toLocaleString('default', { month: 'long' });
        analysis.cashFlow[month] = (analysis.cashFlow[month] || 0) + 1;
    });
    
    // Generate recommendations
    analysis.recommendations = generateWaveRecommendations(analysis);
    
    return analysis;
}

// Generate Wave Accounting recommendations
function generateWaveRecommendations(analysis) {
    const recommendations = [];
    
    // High receipt activity indicates good expense tracking
    if (analysis.receiptActivity.highTracking > 15) {
        recommendations.push({
            type: 'insight',
            priority: 'medium',
            title: 'Excellent Expense Tracking',
            description: `Found ${analysis.receiptActivity.highTracking} receipt files - outstanding expense documentation`,
            action: 'Maintain current expense tracking practices for tax optimization'
        });
    }
    
    // Customer income patterns
    if (analysis.incomeSources.customers > 10) {
        recommendations.push({
            type: 'opportunity',
            priority: 'high',
            title: 'Strong Customer Base',
            description: `${analysis.incomeSources.customers} customer-related files - diverse revenue streams`,
            action: 'Develop customer retention programs and upselling strategies'
        });
    }
    
    // Vendor management insights
    if (analysis.vendorPatterns.suppliers > 8) {
        recommendations.push({
            type: 'trend',
            priority: 'medium',
            title: 'Broad Supplier Network',
            description: `${analysis.vendorPatterns.suppliers} supplier files - good procurement diversity`,
            action: 'Negotiate bulk discounts with top suppliers for cost reduction'
        });
    }
    
    // Cash flow reporting quality
    if (analysis.cashFlow.reports > 5) {
        recommendations.push({
            type: 'insight',
            priority: 'high',
            title: 'Advanced Financial Reporting',
            description: `Multiple cash flow and financial reports - sophisticated financial management`,
            action: 'Use cash flow insights for strategic planning and investment decisions'
        });
    }
    
    // Expense category analysis
    if (analysis.expenseCategories.materials > 10) {
        recommendations.push({
            type: 'action',
            priority: 'medium',
            title: 'Material Cost Optimization',
            description: `High volume of material expense tracking - opportunity for cost control`,
            action: 'Analyze material cost trends and negotiate better supplier terms'
        });
    }
    
    // Transaction volume insights
    const totalTransactions = Object.values(analysis.transactionTypes).reduce((sum, count) => sum + count, 0);
    if (totalTransactions > 50) {
        recommendations.push({
            type: 'insight',
            priority: 'medium',
            title: 'High Transaction Volume',
            description: `${totalTransactions} transaction files - active business operations`,
            action: 'Consider automating transaction processing for efficiency gains'
        });
    }
    
    return recommendations;
}

// Check if file is ATP-related
function isATPFile(filename) {
    const atpPatterns = [
        'atp', 'watts', 'justin watts', 'wsi', 'watts safety', 'bid', 'quote', 
        'estimate', 'contract', 'proposal', 'assistive', 'tech', 'assistive technology',
        'north park', 'allen', 'smith', 'kent', 'esperanza', 'pleasant', 'jayne'
    ];
    
    const lowerFilename = filename.toLowerCase();
    return atpPatterns.some(pattern => lowerFilename.includes(pattern.toLowerCase()));
}

// Check if email is ATP-related
function isATPEmail(message) {
    const headers = message.payload.headers;
    const subject = headers.find(h => h.name === 'Subject')?.value || '';
    const from = headers.find(h => h.name === 'From')?.value || '';
    
    const atpPatterns = [
        'atp', 'watts', 'justin watts', 'wsi', 'watts safety', 'bid', 'quote', 
        'estimate', 'contract', 'proposal', 'assistive', 'tech', 'assistive technology',
        'north park', 'allen', 'smith', 'kent', 'esperanza', 'pleasant', 'jayne'
    ];
    
    const stateDomainPattern = /@(.*\.)?(gov|state\..*\.us)$/;
    
    const lowerSubject = subject.toLowerCase();
    const lowerFrom = from.toLowerCase();
    
    return atpPatterns.some(pattern => 
        lowerSubject.includes(pattern.toLowerCase()) || lowerFrom.includes(pattern.toLowerCase())
    ) || stateDomainPattern.test(lowerFrom);
}

// Display scan results with comprehensive report
function displayScanResults(service, allItems, atpItems) {
    const resultsContainer = document.getElementById('scanResults');
    
    // Create summary report
    const summaryHTML = `
        <div class="scan-summary" style="background: #0f1a33; border: 1px solid #3498db; border-radius: 10px; padding: 20px; margin-bottom: 20px;">
            <h3 style="color: #3498db; margin-bottom: 15px;">üìä Scan Report - ${service === 'drive' ? 'Google Drive' : service === 'gmail' ? 'Gmail' : service === 'financials' ? 'WSI Financials' : 'Wave Accounting'}</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                <div style="text-align: center; padding: 15px; background: #1a2744; border-radius: 8px;">
                    <div style="font-size: 24px; font-weight: bold; color: #3498db;">${allItems.length}</div>
                    <div style="font-size: 12px; color: #7f8c8d;">Total Items Scanned</div>
                </div>
                <div style="text-align: center; padding: 15px; background: #1a2744; border-radius: 8px;">
                    <div style="font-size: 24px; font-weight: bold; color: #27ae60;">${atpItems.length}</div>
                    <div style="font-size: 12px; color: #7f8c8d;">ATP Items Found</div>
                </div>
                <div style="text-align: center; padding: 15px; background: #1a2744; border-radius: 8px;">
                    <div style="font-size: 24px; font-weight: bold; color: #f39c12;">${Math.round((atpItems.length / allItems.length) * 100) || 0}%</div>
                    <div style="font-size: 12px; color: #7f8c8d;">Match Rate</div>
                </div>
            </div>
            <div style="margin-top: 15px; padding: 10px; background: #16213e; border-radius: 5px;">
                <div style="font-size: 12px; color: #7f8c8d;">Scan completed at: ${new Date().toLocaleString()}</div>
                <div style="font-size: 12px; color: #7f8c8d;">Search terms: atp, watts, bid, quote, contract, assistive, tech, state domains</div>
                ${allItems.some(item => item.isLocal) ? '<div style="font-size: 12px; color: #27ae60;">‚úÖ Local file upload processed</div>' : ''}
            </div>
        </div>
    `;
    
    // Create detailed results
    const resultsHTML = atpItems.map((item, index) => {
        if (service === 'drive' || service === 'financials' || service === 'wave') {
            const isLocal = item.isLocal || false;
            const size = item.size || 0;
            const modifiedTime = item.modifiedTime || item.lastModified || new Date().toISOString();
            
            return `
                <div class="result-item atp" style="background: #1a2744; border: 1px solid #27ae60; border-radius: 8px; padding: 15px; margin-bottom: 10px;">
                    <div style="flex: 1;">
                        <div style="font-weight: bold; color: #27ae60; margin-bottom: 5px;">üìÑ ${item.name}</div>
                        <div style="font-size: 12px; color: #7f8c8d; line-height: 1.4;">
                            <div>Type: ${item.type || item.mimeType || 'Unknown'}</div>
                            <div>Size: ${formatFileSize(size)}</div>
                            <div>Modified: ${new Date(modifiedTime).toLocaleDateString()}</div>
                            <div>ID: ${item.id}</div>
                            ${isLocal ? '<div style="color: #27ae60;">‚úÖ Local Upload</div>' : ''}
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <span style="background: #27ae60; color: white; padding: 4px 8px; border-radius: 12px; font-size: 10px;">ATP MATCH</span>
                        <button class="btn btn-primary" onclick="viewFile('${item.id}', '${item.name}')" style="padding: 8px 16px; font-size: 12px;">${isLocal ? 'üìÅ Open' : 'View'}</button>
                    </div>
                </div>
            `;
        } else if (service === 'gmail') {
            const subject = item.payload?.headers?.find(h => h.name === 'Subject')?.value || item.subject || 'No Subject';
            const from = item.payload?.headers?.find(h => h.name === 'From')?.value || item.from || 'Unknown';
            const date = item.payload?.headers?.find(h => h.name === 'Date')?.value || item.date || '';
            const to = item.payload?.headers?.find(h => h.name === 'To')?.value || item.to || '';
            
            return `
                <div class="result-item atp" style="background: #1a2744; border: 1px solid #27ae60; border-radius: 8px; padding: 15px; margin-bottom: 10px;">
                    <div style="flex: 1;">
                        <div style="font-weight: bold; color: #27ae60; margin-bottom: 5px;">üìß ${subject}</div>
                        <div style="font-size: 12px; color: #7f8c8d; line-height: 1.4;">
                            <div>From: ${from}</div>
                            <div>To: ${to}</div>
                            <div>Date: ${new Date(date).toLocaleDateString()}</div>
                            <div>ID: ${item.id}</div>
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <span style="background: #27ae60; color: white; padding: 4px 8px; border-radius: 12px; font-size: 10px;">ATP MATCH</span>
                        <button class="btn btn-primary" onclick="viewEmail('${item.id}')" style="padding: 8px 16px; font-size: 12px;">View</button>
                    </div>
                </div>
            `;
        }
    }).join('');
    
    // Combine summary and results
    const fullHTML = summaryHTML + 
        (resultsHTML || '<div class="result-item other" style="background: #1a2744; border: 1px solid #e74c3c; border-radius: 8px; padding: 15px; margin-bottom: 10px;">‚ùå No ATP items found</div>') +
        `
        <div style="margin-top: 20px; text-align: center;">
            <button class="btn btn-success" onclick="exportResults()" style="margin-right: 10px;">üìä Export Report</button>
            <button class="btn btn-primary" onclick="importAllResults()">üöÄ Import to Bid Generator</button>
        </div>
    `;
    
    resultsContainer.innerHTML = fullHTML;
    
    // Show the results card
    document.getElementById('resultsCard').style.display = 'block';
    
    // Update stats
    document.getElementById('totalScanned').textContent = allItems.length;
    document.getElementById('atpFound').textContent = atpItems.length;
    document.getElementById('newBids').textContent = atpItems.filter(item => item.isNew).length;
    document.getElementById('imported').textContent = '0';
    
    // Store results for export
    window.scanResults = window.scanResults || {};
    window.scanResults[service] = {
        allItems: allItems,
        atpItems: atpItems,
        scanTime: new Date().toISOString(),
        summary: {
            total: allItems.length,
            atpMatches: atpItems.length,
            matchRate: Math.round((atpItems.length / allItems.length) * 100) || 0
        }
    };
    
    // Show detailed notification
    showNotification(`üìä Scan Complete! Found ${atpItems.length} ATP items out of ${allItems.length} total (${Math.round((atpItems.length / allItems.length) * 100) || 0}% match rate)`, 'success');
}

// Format file size
function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

// View file
function viewFile(fileId, filename) {
    window.open(`https://drive.google.com/file/d/${fileId}/view`, '_blank');
}

// View email
function viewEmail(messageId) {
    window.open(`https://mail.google.com/#inbox/${messageId}`, '_blank');
}

function importAllResults() {
    showNotification('üöÄ Importing ATP items to bid generator...', 'info');
    // TODO: Implement import logic
}

function exportResults() {
    const scanResults = window.scanResults || {};
    const reportData = {
        scanDate: new Date().toISOString(),
        summary: {
            totalDriveFiles: scanResults.drive?.summary?.total || 0,
            atpDriveFiles: scanResults.drive?.summary?.atpMatches || 0,
            totalGmailMessages: scanResults.gmail?.summary?.total || 0,
            atpGmailMessages: scanResults.gmail?.summary?.atpMatches || 0,
            overallMatchRate: 0
        },
        driveResults: scanResults.drive?.atpItems || [],
        gmailResults: scanResults.gmail?.atpItems || []
    };
    
    // Calculate overall match rate
    const totalItems = reportData.summary.totalDriveFiles + reportData.summary.totalGmailMessages;
    const totalAtpItems = reportData.summary.atpDriveFiles + reportData.summary.atpGmailMessages;
    reportData.summary.overallMatchRate = totalItems > 0 ? Math.round((totalAtpItems / totalItems) * 100) : 0;
    
    // Create detailed report
    let reportText = `
========================================
ATP BID GENERATOR - GOOGLE SCAN REPORT
========================================

Scan Date: ${new Date(reportData.scanDate).toLocaleString()}
Scan Duration: Real-time scan of Google Drive and Gmail

========================================
EXECUTIVE SUMMARY
========================================

Google Drive:
- Total files scanned: ${reportData.summary.totalDriveFiles}
- ATP-related files found: ${reportData.summary.atpDriveFiles}
- Drive match rate: ${scanResults.drive?.summary?.matchRate || 0}%

Gmail:
- Total messages scanned: ${reportData.summary.totalGmailMessages}
- ATP-related messages found: ${reportData.summary.atpGmailMessages}
- Gmail match rate: ${scanResults.gmail?.summary?.matchRate || 0}%

Overall:
- Total items scanned: ${totalItems}
- Total ATP items found: ${totalAtpItems}
- Overall match rate: ${reportData.summary.overallMatchRate}%

========================================
DETAILED RESULTS - GOOGLE DRIVE
========================================
`;

    // Add Drive results
    if (reportData.driveResults.length > 0) {
        reportData.driveResults.forEach((file, index) => {
            reportText += `
${index + 1}. ${file.name}
   Type: ${file.mimeType}
   Size: ${formatFileSize(file.size)}
   Modified: ${new Date(file.modifiedTime).toLocaleString()}
   ID: ${file.id}
   Link: https://drive.google.com/file/d/${file.id}/view
`;
        });
    } else {
        reportText += "\nNo ATP-related files found in Google Drive.\n";
    }

    reportText += `
========================================
DETAILED RESULTS - GMAIL
========================================
`;

    // Add Gmail results
    if (reportData.gmailResults.length > 0) {
        reportData.gmailResults.forEach((email, index) => {
            const subject = email.payload.headers.find(h => h.name === 'Subject')?.value || 'No Subject';
            const from = email.payload.headers.find(h => h.name === 'From')?.value || 'Unknown';
            const date = email.payload.headers.find(h => h.name === 'Date')?.value || '';
            const to = email.payload.headers.find(h => h.name === 'To')?.value || '';
            
            reportText += `
${index + 1}. ${subject}
   From: ${from}
   To: ${to}
   Date: ${new Date(date).toLocaleString()}
   ID: ${email.id}
   Link: https://mail.google.com/#inbox/${email.id}
`;
        });
    } else {
        reportText += "\nNo ATP-related messages found in Gmail.\n";
    }

    reportText += `
========================================
SEARCH CRITERIA
========================================

Search Terms Used:
- atp, watts, justin watts, wsi, watts safety
- bid, quote, estimate, contract, proposal
- assistive, tech, assistive technology
- north park, allen, smith, kent, esperanza, pleasant, jayne
- State domain emails: *@*.gov and *@*.state.*.us

File Types Searched:
- All file types in Google Drive
- All email messages in Gmail

Permissions:
- Read-only access only
- No files or emails were modified

========================================
RECOMMENDATIONS
========================================

1. Review the ${totalAtpItems} ATP-related items found
2. Import relevant items to the bid generator
3. Consider setting up automated scans for future bids
4. Review state domain communications for opportunities

========================================
END OF REPORT
========================================
`;

    // Create and download the report
    const blob = new Blob([reportText], { type: 'text/plain' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `ATP-Scan-Report-${new Date().toISOString().split('T')[0]}.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    window.URL.revokeObjectURL(url);
    
    showNotification(`üìä Report exported! ${totalAtpItems} ATP items found`, 'success');
}

// ========================================
// LOCAL FILE SYSTEM SCANNER IMPLEMENTATION
// ========================================

// Enhanced Local File Scanner - Memory Safe Implementation
class LocalFileScanner {
    constructor() {
        this.supportedTypes = ['.pdf', '.doc', '.docx', '.txt', '.csv', '.xlsx', '.xls'];
        this.quoteFiles = [];
        this.processedFiles = [];
        this.nlpEngine = new LocalNLPProcessor();
        this.batchSize = 5; // Increased for speed
        this.maxFileSize = 10 * 1024 * 1024; // 10MB limit
        this.maxTotalSize = 50 * 1024 * 1024; // 50MB total limit
        this.scanQueue = [];
        this.isScanning = false;
        this.abortController = null;
    }

    // Handle local file selection (memory safe)
    async handleLocalFileScan(event) {
        // Create abort controller for cancellation
        this.abortController = new AbortController();
        
        const files = Array.from(event.target.files);
        console.log(`üìÅ Selected ${files.length} local files for memory-safe scanning`);
        
        // Early size filtering to prevent crashes
        const totalSize = files.reduce((sum, file) => sum + file.size, 0);
        if (totalSize > this.maxTotalSize) {
            showNotification(`‚ùå Total file size (${(totalSize/1024/1024).toFixed(1)}MB) exceeds 50MB limit. Select fewer files.`, 'error');
            return;
        }
        
        // Filter files first before processing
        const relevantFiles = this.filterRelevantFiles(files);
        console.log(`üìã Filtered to ${relevantFiles.length} relevant files`);
        
        if (relevantFiles.length === 0) {
            showNotification('üìÑ No relevant files found (no quote/bid/estimate keywords)', 'info');
            return;
        }
        
        // Warn if too many files
        if (relevantFiles.length > 50) {
            showNotification(`‚ö†Ô∏è ${relevantFiles.length} files found. Processing first 50 to prevent crashes.`, 'warning');
            relevantFiles.splice(50);
        }
        
        showNotification(`üìÅ Processing ${relevantFiles.length} relevant files safely...`, 'info');
        this.updateProgress(0, relevantFiles.length, 'Starting memory-safe scan...');
        
        try {
            const quoteFiles = await this.processFilesInBatches(relevantFiles);
            this.quoteFiles = quoteFiles;
            this.displayLocalResults(quoteFiles);
            this.storeLocalData(quoteFiles);
            
            showNotification(`‚úÖ Safe scan complete: ${quoteFiles.length} quote files found`, 'success');
            this.updateLocalStatus(`Safe-scanned (${quoteFiles.length} files)`);
            
        } catch (error) {
            console.error('Safe scan error:', error);
            if (error.name === 'AbortError') {
                showNotification('üõë Scan cancelled by user', 'info');
            } else {
                showNotification('‚ùå Scan completed with some errors', 'warning');
            }
        } finally {
            this.abortController = null;
        }
    }

    // Filter files by filename first (much faster than content reading)
    filterRelevantFiles(files) {
        const keywords = [
            'quote', 'bid', 'estimate', 'proposal', 'contract', 'invoice',
            'atp', 'dhhs', 'nebraska', 'materials', 'request'
        ];
        
        return files.filter(file => {
            // Skip files larger than 10MB
            if (file.size > this.maxFileSize) {
                console.log(`‚ö†Ô∏è Skipping large file: ${file.name} (${(file.size/1024/1024).toFixed(1)}MB)`);
                return false;
            }
            
            const fileName = file.name.toLowerCase();
            const fileExtension = '.' + fileName.split('.').pop().toLowerCase();
            
            // Check filename for keywords
            const hasKeyword = keywords.some(keyword => fileName.includes(keyword));
            const isSupportedType = this.supportedTypes.includes(fileExtension);
            
            return hasKeyword || isSupportedType;
        });
    }

    // Process files in small batches to prevent memory issues
    async processFilesInBatches(files) {
        const quoteFiles = [];
        let processedCount = 0;
        
        // Process in batches of 3 files (reduced from 10)
        for (let i = 0; i < files.length; i += this.batchSize) {
            // Check if scan was aborted
            if (this.abortController?.signal.aborted) {
                throw new Error('AbortError');
            }
            
            const batch = files.slice(i, i + this.batchSize);
            
            this.updateProgress(processedCount, files.length, 
                `Processing batch ${Math.floor(i/this.batchSize) + 1}/${Math.ceil(files.length/this.batchSize)}...`);
            
            // Process files sequentially (not concurrently) to reduce memory pressure
            for (const file of batch) {
                if (this.abortController?.signal.aborted) {
                    throw new Error('AbortError');
                }
                
                try {
                    const result = await this.processFileSafely(file);
                    if (result && result.isQuote) {
                        quoteFiles.push(result);
                    }
                } catch (error) {
                    console.error(`Error processing ${file.name}:`, error);
                    // Continue with other files
                }
                
                processedCount++;
                
                // Update progress for each file
                this.updateProgress(processedCount, files.length, 
                    `Processed ${processedCount}/${files.length} files...`);
                
                // Force garbage collection hint
                if (processedCount % 10 === 0) {
                    await this.sleep(200); // Longer pause every 10 files
                    if (window.gc) window.gc(); // Force GC if available
                } else {
                    await this.sleep(50); // Reduced pause between files
                }
            }
        }
        
        return quoteFiles;
    }

    // Process single file safely with memory management
    async processFileSafely(file) {
        try {
            const fileName = file.name.toLowerCase();
            const extension = '.' + fileName.split('.').pop().toLowerCase();
            
            // Check for abort signal
            if (this.abortController?.signal.aborted) {
                throw new Error('AbortError');
            }
            
            // For binary files (PDF, DOC, XLS), skip content reading and use metadata only
            const binaryExtensions = ['.pdf', '.doc', '.docx', '.xls', '.xlsx'];
            if (binaryExtensions.includes(extension)) {
                // Quick metadata-only processing for binary files
                const keywords = ['quote', 'bid', 'estimate', 'proposal', 'contract', 'invoice', 'atp'];
                const hasKeyword = keywords.some(keyword => fileName.includes(keyword));
                
                if (hasKeyword) {
                    return {
                        file: file,
                        content: `Binary file: ${file.name}`,
                        parsedData: {
                            isQuote: true,
                            isNew: false,
                            client: null,
                            location: null,
                            projectType: null,
                            complexity: 'unknown',
                            confidence: 50
                        },
                        source: 'local_safe',
                        timestamp: new Date().toISOString()
                    };
                }
                return { isQuote: false };
            }
            
            // For text files, do full processing
            const content = await this.extractFileContentSafely(file);
            
            if (this.abortController?.signal.aborted) {
                throw new Error('AbortError');
            }
            
            // Full NLP processing for text files
            const parsedData = this.nlpEngine.parseQuoteData(content, file.name);
            
            if (parsedData.isQuote) {
                return {
                    file: file,
                    content: this.truncateContent(content),
                    parsedData: parsedData,
                    source: 'local_safe',
                    timestamp: new Date().toISOString()
                };
            }
            
            return { isQuote: false };
            
        } catch (error) {
            console.error(`Safe processing error for ${file.name}:`, error);
            return { isQuote: false, error: error.message };
        }
    }


    // Extract content with memory limits
    async extractFileContentSafely(file) {
        const fileName = file.name.toLowerCase();
        const extension = fileName.split('.').pop();
        const maxSize = 5 * 1024 * 1024; // 5MB limit
        
        // Skip files larger than 5MB
        if (file.size > maxSize) {
            console.log(`Skipping large file: ${file.name} (${file.size} bytes)`);
            return `Large file skipped: ${file.name}`;
        }
        
        try {
            switch (extension) {
                case 'txt':
                    return await this.readTextFileSafely(file);
                case 'csv':
                    return await this.readCSVFileSafely(file);
                case 'pdf':
                    return `PDF File: ${file.name} (Size: ${file.size} bytes)`;
                case 'doc':
                case 'docx':
                    return `Word Document: ${file.name} (Size: ${file.size} bytes)`;
                case 'xls':
                case 'xlsx':
                    return `Excel File: ${file.name} (Size: ${file.size} bytes)`;
                default:
                    return await this.readTextFileSafely(file);
            }
        } catch (error) {
            console.error(`Error extracting content from ${fileName}:`, error);
            return `Error reading file: ${error.message}`;
        }
    }

    // Safe text file reading with size limit
    async readTextFileSafely(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            
            reader.onload = (e) => {
                const content = e.target.result;
                // Truncate to prevent memory issues
                const maxLength = 10000; // 10KB max per file
                const truncated = content.length > maxLength ? 
                    content.substring(0, maxLength) + '...[truncated]' : content;
                resolve(truncated);
            };
            
            reader.onerror = (e) => reject(e.target.error);
            reader.readAsText(file);
        });
    }

    // Safe CSV reading
    async readCSVFileSafely(file) {
        const content = await this.readTextFileSafely(file);
        // Only read first 50 lines of CSV
        const lines = content.split('\n').slice(0, 50);
        return lines.join('\n');
    }

    // Truncate content to save memory
    truncateContent(content) {
        const maxLength = 2000; // Store only 2KB per file
        return content.length > maxLength ? 
            content.substring(0, maxLength) + '...[truncated]' : content;
    }

    // Helper function for delays
    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    // Enhanced auto-scan with memory safety
    async autoScanLocalPC() {
        console.log('üîç Starting memory-safe automatic PC scan...');
        
        if (this.isScanning) {
            showNotification('‚ö†Ô∏è Scan already in progress...', 'warning');
            return;
        }
        
        this.isScanning = true;
        this.updateProgress(0, 100, 'Initializing memory-safe scan...');
        
        try {
            // Prompt user for directory selection
            const files = await this.promptForDirectoryScan();
            
            if (!files || files.length === 0) {
                showNotification('üìÅ No files selected for scanning', 'info');
                return;
            }
            
            // Filter and process safely
            const relevantFiles = this.filterRelevantFiles(files);
            console.log(`üìã Found ${relevantFiles.length} relevant files out of ${files.length} total`);
            
            if (relevantFiles.length > 500) {
                showNotification(`‚ö†Ô∏è Large dataset detected (${relevantFiles.length} files). Processing in safe mode...`, 'warning');
            }
            
            this.updateProgress(5, 100, `Processing ${relevantFiles.length} files safely...`);
            
            const quoteFiles = await this.processFilesInBatches(relevantFiles);
            
            // Final update
            this.updateProgress(95, 100, 'Finalizing results...');
            
            this.quoteFiles = quoteFiles;
            this.displayLocalResults(quoteFiles);
            this.storeLocalData(quoteFiles);
            
            this.updateProgress(100, 100, `‚úÖ Safe scan complete! Found ${quoteFiles.length} quote files`);
            
            showNotification(`‚úÖ Memory-safe scan complete: ${quoteFiles.length} quote files found from ${files.length} files scanned`, 'success');
            this.updateLocalStatus(`Safe-scanned (${quoteFiles.length} files)`);
            
        } catch (error) {
            console.error('Safe auto-scan failed:', error);
            showNotification('‚ùå Scan failed. Try selecting a smaller folder.', 'error');
        } finally {
            this.isScanning = false;
            
            // Hide progress after completion
            setTimeout(() => {
                const progressCard = document.getElementById('progressCard');
                if (progressCard) {
                    progressCard.style.display = 'none';
                }
            }, 3000);
        }
    }

    // Prompt for directory selection
    async promptForDirectoryScan() {
        return new Promise((resolve, reject) => {
            const input = document.createElement('input');
            input.type = 'file';
            input.webkitdirectory = true;
            input.multiple = true;
            
            input.onchange = (event) => {
                const files = Array.from(event.target.files);
                resolve(files);
            };
            
            input.oncancel = () => {
                resolve([]);
            };
            
            // Show user-friendly prompt
            showNotification('üìÅ Select a folder to scan for quote files (processed safely)...', 'info');
            
            // Trigger file selection
            input.click();
        });
    }

    // Update progress indicator
    updateProgress(current, total, message) {
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const progressCard = document.getElementById('progressCard');
        
        if (progressCard) {
            progressCard.style.display = 'block';
        }
        
        if (progressFill && progressText) {
            const percentage = Math.round((current / total) * 100);
            progressFill.style.width = `${percentage}%`;
            progressText.textContent = message;
        }
        
        if (current === total) {
            setTimeout(() => {
                if (progressCard) {
                    progressCard.style.display = 'none';
                }
            }, 2000);
        }
    }

    // Display local scan results
    displayLocalResults(quoteFiles) {
        const resultsCard = document.getElementById('resultsCard');
        const scanResults = document.getElementById('scanResults');
        
        if (!resultsCard || !scanResults) return;
        
        resultsCard.style.display = 'block';
        
        // Update stats
        document.getElementById('totalScanned').textContent = quoteFiles.length;
        document.getElementById('atpFound').textContent = quoteFiles.length;
        document.getElementById('newBids').textContent = quoteFiles.filter(f => f.parsedData.isNew).length;
        
        // Display results
        scanResults.innerHTML = quoteFiles.map(file => `
            <div class="result-item atp">
                <div>
                    <strong>üìÑ ${file.file.name}</strong>
                    <div style="font-size: 11px; color: #7f8c8d; margin-top: 2px;">
                        ${file.parsedData.client ? `Client: ${file.parsedData.client}` : 'Client: Unknown'}
                        ${file.parsedData.location ? ` | Location: ${file.parsedData.location}` : ''}
                        ${file.parsedData.totalPrice ? ` | Price: $${file.parsedData.totalPrice.toLocaleString()}` : ''}
                    </div>
                </div>
                <div style="font-size: 10px; color: #3498db;">
                    Local File
                </div>
            </div>
        `).join('');
    }

    // Store local data in localStorage and Firebase
    storeLocalData(quoteFiles) {
        // Log data flow event
        if (dataFlowMonitor) {
            dataFlowMonitor.logEvent('LOCAL', `Storing ${quoteFiles.length} quote files to LocalStorage`);
            dataFlowMonitor.updateStats('localScanned', quoteFiles.length);
        }
        
        // Store in localStorage for immediate access
        const localData = {
            source: 'local',
            timestamp: new Date().toISOString(),
            files: quoteFiles.map(f => ({
                name: f.file.name,
                size: f.file.size,
                type: f.file.type,
                parsedData: f.parsedData,
                content: f.content.substring(0, 1000) // Store first 1000 chars
            }))
        };
        
        // Save to Firebase for cross-domain syncing
        if (db) {
            const scanData = {
                results: localData,
                timestamp: new Date().getTime(),
                source: 'local_scanner',
                version: '1.0'
            };
            
            db.ref('shared/localScanResults').set(scanData)
                .then(() => {
                    if (dataFlowMonitor) {
                        dataFlowMonitor.logEvent('STORAGE', `Local scan data synced to Firebase`);
                    }
                })
                .catch(error => {
                    console.error('Firebase sync failed, using localStorage:', error);
                    if (dataFlowMonitor) {
                        dataFlowMonitor.logEvent('STORAGE', `Local scan data stored in LocalStorage (Firebase failed)`);
                    }
                });
        }
        
        // Always save to localStorage as backup
        localStorage.setItem('localScanResults', JSON.stringify(localData));
        
        // Store in Firebase for persistence
        const userPIN = sessionStorage.getItem('bid_pin');
        if (userPIN) {
            const hashed = hashPIN(userPIN);
            db.ref(`googleIntelligence/${hashed}/local`).set(localData)
                .then(() => {
                    if (dataFlowMonitor) {
                        dataFlowMonitor.logEvent('FIREBASE', `Local data synced to Firebase successfully`);
                        dataFlowMonitor.updateStats('firebaseSynced', 1);
                    }
                })
                .catch(error => {
                    if (dataFlowMonitor) {
                        dataFlowMonitor.logEvent('FIREBASE', `Firebase sync error: ${error.message}`);
                    }
                });
        } else {
            if (dataFlowMonitor) {
                dataFlowMonitor.logEvent('FIREBASE', 'No user PIN - Firebase sync skipped');
            }
        }
    }

    // Update local status
    updateLocalStatus(status) {
        const localStatus = document.getElementById('localStatus');
        if (localStatus) {
            localStatus.textContent = status;
            localStatus.className = 'service-status status-connected';
        }
    }

    // Auto-scan entire local PC for quote files
    async autoScanLocalPC() {
        console.log('üîç Starting automatic PC scan for quote files...');
        
        this.updateProgress(0, 100, 'Initializing automatic scan...');
        
        try {
            // Get user's home directory and common document folders
            const searchPaths = await this.getCommonDocumentPaths();
            
            let totalFiles = 0;
            let processedFiles = 0;
            let quoteFiles = [];
            
            // Update progress for path discovery
            this.updateProgress(1, 100, `Found ${searchPaths.length} directories to scan...`);
            
            // Scan each path
                
                // Hide progress after completion
                setTimeout(() => {
                    const progressCard = document.getElementById('progressCard');
                    if (progressCard) {
                        progressCard.style.display = 'none';
                    }
                }, 3000);
            }
            
            this.updateProgress(100, 100, `Scan complete! Found ${quoteFiles.length} quote files`);
            
            showNotification(`‚úÖ Auto-scan complete: ${quoteFiles.length} quote files found from ${totalFiles} files scanned`, 'success');
            this.updateLocalStatus(`Auto-scanned (${quoteFiles.length} files)`);
            
            // Hide progress after completion
            setTimeout(() => {
                const progressCard = document.getElementById('progressCard');
                if (progressCard) {
                    progressCard.style.display = 'none';
                }
            }, 3000);
            
        } catch (error) {
            console.error('Auto-scan failed:', error);
            throw error;
        }
    }

    // Get common document paths to search
    async getCommonDocumentPaths() {
        // Common Windows document folders
        const commonPaths = [
            'C:\\Users\\' + this.getUsername() + '\\Documents',
            'C:\\Users\\' + this.getUsername() + '\\Desktop',
            'C:\\Users\\' + this.getUsername() + '\\Downloads',
            'C:\\Users\\' + this.getUsername() + '\\OneDrive',
            'C:\\Users\\' + this.getUsername() + '\\OneDrive\\Documents',
            'C:\\Users\\' + this.getUsername() + '\\OneDrive\\Desktop',
            'D:\\Documents',
            'D:\\Users\\' + this.getUsername() + '\\Documents',
            'C:\\Documents',
            'C:\\Users\\Public\\Documents'
        ];
        
        // Filter to only existing paths (browser security limitations apply)
        const validPaths = [];
        
        // For security reasons, we'll use a more limited approach
        // Focus on the most likely locations
        const priorityPaths = [
            'C:\\Users\\' + this.getUsername() + '\\Documents',
            'C:\\Users\\' + this.getUsername() + '\\Desktop',
            'C:\\Users\\' + this.getUsername() + '\\Downloads'
        ];
        
        return priorityPaths;
    }

    // Get current username
    getUsername() {
        // In a real implementation, this would get the actual username
        // For browser security, we'll use a placeholder
        return 'User'; // This would need to be dynamically determined
    }

    // Scan directory for quote files (simulated due to browser security)
    async scanDirectoryForQuotes(directoryPath) {
        console.log(`üìÅ Scanning directory: ${directoryPath}`);
        
        // Due to browser security restrictions, we cannot directly access local file system
        // Instead, we'll prompt user to select the directory and then scan it
        return new Promise((resolve, reject) => {
            // Create a hidden file input for directory selection
            const input = document.createElement('input');
            input.type = 'file';
            input.webkitdirectory = true;
            input.multiple = true;
            
            input.onchange = (event) => {
                const files = Array.from(event.target.files);
                const quoteFiles = this.filterRelevantFiles(files);
                
                resolve({
                    total: files.length,
                    quoteFiles: quoteFiles
                });
            };
            
            input.oncancel = () => {
                reject(new Error('Directory selection cancelled'));
            };
            
            // Show user-friendly prompt
            showNotification('üìÅ Please select a folder to scan for quote files...', 'info');
            
            // Trigger file selection
            input.click();
        });
    }
}

// Local NLP Processor for extracting quote data
class LocalNLPProcessor {
    constructor() {
        this.scopePatterns = this.initScopePatterns();
        this.competitorPatterns = this.initCompetitorPatterns();
        this.pricePatterns = this.initPricePatterns();
    }

    // Initialize scope extraction patterns
    initScopePatterns() {
        return {
            client: [
                /(?:client|customer|for|project:?)\s*([A-Z][a-z\s]+(?:School|Elementary|High|Middle|District|ISD))/gi,
                /(?:North Park|Allen|Smith|Kent|Esperanza|Pleasant|Jayne)/gi
            ],
            location: [
                /(?:location|in|at)\s*([A-Z][a-z\s]+,\s*[A-Z]{2})/gi,
                /([A-Z][a-z]+),\s*([A-Z]{2})/gi
            ],
            projectType: [
                /(?:full|complete|total)\s*(?:bathroom|restroom)\s*(?:remodel|renovation|rebuild)/gi,
                /(?:handrail|grab\s*bar)\s*(?:install|installation)/gi,
                /(?:shower|tub)\s*(?:install|installation|replacement)/gi,
                /(?:accessibility|ada|compliance)/gi
            ],
            dimensions: [
                /(\d+)\s*[xX√ó]\s*(\d+)/gi,
                /(\d+)\s*(?:inch|in|")\s*[xX√ó]\s*(\d+)\s*(?:inch|in|")/gi
            ],
            requirements: [
                /(?:electrical|electric)\s*(?:work|needed|required)/gi,
                /(?:plumbing|plumber)\s*(?:work|needed|required)/gi,
                /(?:translator|interpret)/gi
            ]
        };
    }

    // Initialize competitor patterns
    initCompetitorPatterns() {
        return [
            /(?:winning|lowest|awarded)\s*(?:bid|contract)\s*(?:was|to|by)\s*([A-Z][a-z\s]+(?:Construction|Contracting|Remodeling|Builders|Install))/gi,
            /(?:bid\s*(?:against|vs|versus)|competing\s*with)\s*([A-Z][a-z\s]+(?:Construction|Contracting|Remodeling))/gi,
            /(?:CC:|From:)\s*([^@]+@(?:[^.]+\.)+(?:com|net|org))/gi
        ];
    }

    // Initialize price patterns
    initPricePatterns() {
        return [
            /\$(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)/g,
            /(?:price|cost|bid|quote|estimate)\s*:?\s*\$(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)/gi,
            /(?:total|amount)\s*:?\s*\$(\d{1,3}(?:,\d{3})*(?:\.\d{2})?)/gi
        ];
    }

    // Parse quote data from content
    parseQuoteData(content, fileName) {
        const parsed = {
            isQuote: false,
            isNew: false,
            client: null,
            location: null,
            projectType: null,
            complexity: 'simple',
            scope: {},
            competitors: [],
            pricing: {
                yourPrice: null,
                winningPrice: null,
                marketAverage: null,
                prices: []
            },
            confidence: 0
        };

        // Check if this is a quote/bid document
        const quoteKeywords = ['quote', 'bid', 'estimate', 'proposal', 'contract'];
        const contentLower = content.toLowerCase();
        const fileNameLower = fileName.toLowerCase();
        
        parsed.isQuote = quoteKeywords.some(keyword => 
            contentLower.includes(keyword) || fileNameLower.includes(keyword)
        );

        if (!parsed.isQuote) {
            return parsed;
        }

        // Extract client information
        for (const pattern of this.scopePatterns.client) {
            const match = content.match(pattern);
            if (match) {
                parsed.client = match[1] || match[0];
                break;
            }
        }

        // Extract location
        for (const pattern of this.scopePatterns.location) {
            const match = content.match(pattern);
            if (match) {
                parsed.location = match[1] || match[0];
                break;
            }
        }

        // Extract project type
        if (contentLower.includes('handrail') || contentLower.includes('grab bar')) {
            parsed.projectType = 'handrail_install';
            parsed.complexity = 'simple';
        } else if (contentLower.includes('shower') && !contentLower.includes('full')) {
            parsed.projectType = 'shower_install';
            parsed.complexity = 'simple';
        } else if (contentLower.includes('full') || contentLower.includes('complete')) {
            parsed.projectType = 'full_bathroom_remodel';
            parsed.complexity = 'moderate';
        }

        // Extract dimensions
        const dimensionMatch = content.match(this.scopePatterns.dimensions[0]);
        if (dimensionMatch) {
            parsed.scope.dimensions = `${dimensionMatch[1]}x${dimensionMatch[2]}`;
        }

        // Extract requirements
        parsed.scope.electricalNeeded = /electrical/i.test(content);
        parsed.scope.plumbingNeeded = /plumbing/i.test(content);
        parsed.scope.accessibilityRequired = /(?:ada|accessibility)/i.test(content);
        parsed.scope.translatorNeeded = /translator/i.test(content);

        // Calculate line items (proxy for complexity)
        const lines = content.split('\n').filter(line => line.trim().length > 0);
        parsed.scope.lineItemCount = lines.length;

        // Adjust complexity based on factors
        let complexityScore = 0;
        if (parsed.scope.electricalNeeded) complexityScore += 2;
        if (parsed.scope.plumbingNeeded) complexityScore += 2;
        if (parsed.scope.accessibilityRequired) complexityScore += 1;
        if (parsed.scope.translatorNeeded) complexityScore += 1;
        if (parsed.scope.lineItemCount > 10) complexityScore += 1;

        if (complexityScore <= 2) parsed.complexity = 'simple';
        else if (complexityScore <= 4) parsed.complexity = 'moderate';
        else parsed.complexity = 'complex';

        // Extract competitors
        for (const pattern of this.competitorPatterns) {
            const matches = content.matchAll(pattern);
            for (const match of matches) {
                const competitorName = match[1] || match[0];
                if (competitorName && !parsed.competitors.find(c => c.name === competitorName)) {
                    parsed.competitors.push({
                        name: competitorName,
                        type: 'detected'
                    });
                }
            }
        }

        // Extract prices
        const priceMatches = content.match(this.pricePatterns[0]);
        if (priceMatches) {
            parsed.pricing.prices = priceMatches.map(price => 
                parseInt(price.replace(/[$,]/g, ''))
            );
            
            // Calculate average
            if (parsed.pricing.prices.length > 0) {
                parsed.pricing.marketAverage = Math.round(
                    parsed.pricing.prices.reduce((a, b) => a + b, 0) / parsed.pricing.prices.length
                );
            }
        }

        // Calculate confidence based on data completeness
        let confidenceScore = 0;
        if (parsed.client) confidenceScore += 20;
        if (parsed.location) confidenceScore += 15;
        if (parsed.projectType) confidenceScore += 15;
        if (parsed.pricing.prices.length > 0) confidenceScore += 25;
        if (parsed.competitors.length > 0) confidenceScore += 15;
        if (parsed.scope.dimensions) confidenceScore += 10;
        
        parsed.confidence = Math.min(confidenceScore, 100);

        return parsed;
    }
}

// Global scanner instance
let localScanner;

// Initialize local scanner
function initializeLocalScanner() {
    localScanner = new LocalFileScanner();
}

// Handle local file scan
function handleLocalFileScan(event) {
    if (!localScanner) {
        initializeLocalScanner();
    }
    
    // Show cancel button
    document.getElementById('cancelScanBtn').style.display = 'inline-block';
    
    localScanner.handleLocalFileScan(event).finally(() => {
        // Hide cancel button when done
        document.getElementById('cancelScanBtn').style.display = 'none';
    });
}

// Cancel local scan
function cancelLocalScan() {
    if (localScanner && localScanner.abortController) {
        localScanner.abortController.abort();
        showNotification('üõë Cancelling scan...', 'info');
    }
}

// Auto-scan local quotes - Full PC Search Implementation
async function scanLocalQuotes() {
    showNotification('üîç Starting automatic local PC scan for quote files...', 'info');
    
    if (!localScanner) {
        initializeLocalScanner();
    }
    
    try {
        // Start automatic directory scanning
        await localScanner.autoScanLocalPC();
    } catch (error) {
        console.error('Auto-scan failed:', error);
        showNotification('‚ùå Auto-scan failed. Try manual folder selection.', 'error');
        
        // Fallback to manual selection
        const input = document.getElementById('localFileInput');
        if (input) {
            input.click();
        }
    }
}

// ========================================
// DATA FLOW MONITORING SYSTEM
// ========================================

// Data Flow Monitor Class
class DataFlowMonitor {
    constructor() {
        this.transferLog = [];
        this.stats = {
            localScanned: 0,
            localStorageCount: 0,
            firebaseSynced: 0,
            bidGeneratorReady: 0
        };
        this.monitoring = false;
    }

    // Start monitoring data flow
    startMonitoring() {
        this.monitoring = true;
        this.updateStatus('üîÑ Data flow monitoring active');
        this.logEvent('SYSTEM', 'Data flow monitoring started');
        
        // Show the monitoring card
        document.getElementById('dataFlowCard').style.display = 'block';
        
        // Start real-time updates
        this.startRealTimeUpdates();
    }

    // Log data transfer events
    logEvent(source, message, data = null) {
        const timestamp = new Date().toLocaleTimeString();
        const logEntry = `[${timestamp}] ${source}: ${message}`;
        
        this.transferLog.push({
            timestamp: timestamp,
            source: source,
            message: message,
            data: data
        });

        // Update log display
        this.updateLogDisplay();
        
        // Also show notification for important events
        if (source === 'FIREBASE' || source === 'BID_GENERATOR') {
            showNotification(`${source}: ${message}`, 'info');
        }
    }

    // Update log display
    updateLogDisplay() {
        const logDiv = document.getElementById('dataTransferLog');
        if (logDiv) {
            const recentLogs = this.transferLog.slice(-20); // Show last 20 events
            logDiv.innerHTML = recentLogs.map(log => 
                `<div style="margin-bottom: 2px; color: ${this.getSourceColor(log.source)};">
                    ${log.timestamp} [${log.source}] ${log.message}
                </div>`
            ).join('');
            
            // Auto-scroll to bottom
            logDiv.scrollTop = logDiv.scrollHeight;
        }
    }

    // Get color for different sources
    getSourceColor(source) {
        const colors = {
            'SYSTEM': '#3498db',
            'LOCAL': '#27ae60', 
            'STORAGE': '#f39c12',
            'FIREBASE': '#e74c3c',
            'BID_GENERATOR': '#9b59b6'
        };
        return colors[source] || '#ecf0f1';
    }

    // Update statistics
    updateStats(statType, value) {
        this.stats[statType] = value;
        
        // Update UI
        const statElement = document.getElementById(statType);
        if (statElement) {
            statElement.textContent = value;
            
            // Add animation for changes
            statElement.style.color = '#27ae60';
            setTimeout(() => {
                statElement.style.color = '#3498db';
            }, 1000);
        }
    }

    // Update status
    updateStatus(message) {
        const statusDiv = document.getElementById('dataFlowStatus');
        if (statusDiv) {
            statusDiv.innerHTML = message;
        }
    }

    // Start real-time updates
    startRealTimeUpdates() {
        setInterval(() => {
            if (this.monitoring) {
                this.checkDataFlowHealth();
            }
        }, 5000); // Check every 5 seconds
    }

    // Check data flow health
    checkDataFlowHealth() {
        // Check localStorage
        const localData = localStorage.getItem('localScanResults');
        const driveData = localStorage.getItem('googleScanResults');
        
        const totalLocal = localData ? JSON.parse(localData).files?.length || 0 : 0;
        const totalDrive = driveData ? Object.keys(driveData).length : 0;
        
        this.updateStats('localStorageCount', totalLocal + totalDrive);
        
        // Check Firebase connection (safely)
        try {
            if (typeof db !== 'undefined' && db) {
                this.updateStatus('üü¢ Firebase connected | LocalStorage active | Monitoring data flow');
            } else {
                this.updateStatus('üî¥ Firebase initializing | LocalStorage active');
            }
        } catch (error) {
            this.updateStatus('üî¥ Firebase disconnected | LocalStorage active');
        }
    }

    // Verify complete data flow
    async verifyDataFlow() {
        this.logEvent('SYSTEM', 'Starting data flow verification...');
        
        try {
            // Step 1: Check LocalStorage
            const localData = localStorage.getItem('localScanResults');
            if (localData) {
                const parsed = JSON.parse(localData);
                this.logEvent('STORAGE', `LocalStorage contains ${parsed.files?.length || 0} local files`);
                this.updateStats('localStorageCount', parsed.files?.length || 0);
            } else {
                this.logEvent('STORAGE', 'No local scan data found in LocalStorage');
            }

            // Step 2: Check Google scan data
            const googleData = localStorage.getItem('googleScanResults');
            if (googleData) {
                const parsed = JSON.parse(googleData);
                const sources = Object.keys(parsed);
                this.logEvent('STORAGE', `Google scan data: ${sources.join(', ')}`);
                sources.forEach(source => {
                    const count = parsed[source]?.atpItems?.length || 0;
                    this.logEvent('STORAGE', `${source.toUpperCase()}: ${count} items`);
                });
            } else {
                this.logEvent('STORAGE', 'No Google scan data found in LocalStorage');
            }

            // Step 3: Check Firebase connection
            if (db) {
                this.logEvent('FIREBASE', 'Firebase database connection verified');
                
                // Test Firebase read
                const userPIN = sessionStorage.getItem('bid_pin');
                if (userPIN) {
                    const hashed = hashPIN(userPIN);
                    const testRef = db.ref(`googleIntelligence/${hashed}`);
                    
                    testRef.once('value').then(snapshot => {
                        if (snapshot.exists()) {
                            const data = snapshot.val();
                            const itemCount = Object.keys(data).length;
                            this.logEvent('FIREBASE', `Firebase contains ${itemCount} data sources`);
                            this.updateStats('firebaseSynced', itemCount);
                        } else {
                            this.logEvent('FIREBASE', 'No data found in Firebase');
                        }
                    }).catch(error => {
                        this.logEvent('FIREBASE', `Firebase read error: ${error.message}`);
                    });
                } else {
                    this.logEvent('FIREBASE', 'No user PIN found for Firebase access');
                }
            } else {
                this.logEvent('FIREBASE', 'Firebase not connected');
            }

            // Step 4: Check Bid Generator access
            const bidGenData = localStorage.getItem('googleScanResults');
            if (bidGenData) {
                this.logEvent('BID_GENERATOR', 'Data available for Bid Generator import');
                this.updateStats('bidGeneratorReady', 1);
            } else {
                this.logEvent('BID_GENERATOR', 'No data available for Bid Generator');
            }

            this.logEvent('SYSTEM', 'Data flow verification complete');
            
        } catch (error) {
            this.logEvent('SYSTEM', `Verification error: ${error.message}`);
        }
    }

    // Test Bid Generator sync
    async testBidGeneratorSync() {
        this.logEvent('BID_GENERATOR', 'Testing Bid Generator data sync...');
        
        try {
            // Get current scan results
            const scanResults = {
                local: localStorage.getItem('localScanResults'),
                drive: localStorage.getItem('googleScanResults')?.drive || null,
                gmail: localStorage.getItem('googleScanResults')?.gmail || null,
                financials: localStorage.getItem('googleScanResults')?.financials || null,
                wave: localStorage.getItem('googleScanResults')?.wave || null
            };

            // Create test data package
            const testData = {
                timestamp: new Date().toISOString(),
                source: 'data_flow_test',
                scanResults: scanResults,
                totalItems: this.calculateTotalItems(scanResults)
            };

            // Store in LocalStorage (simulating Bid Generator access)
            localStorage.setItem('bidGeneratorTestData', JSON.stringify(testData));
            
            this.logEvent('BID_GENERATOR', `Test data package created: ${testData.totalItems} total items`);
            this.updateStats('bidGeneratorReady', testData.totalItems);

            // Verify Bid Generator can access the data
            setTimeout(() => {
                const retrievedData = localStorage.getItem('bidGeneratorTestData');
                if (retrievedData) {
                    const parsed = JSON.parse(retrievedData);
                    this.logEvent('BID_GENERATOR', '‚úÖ Bid Generator can access test data successfully');
                } else {
                    this.logEvent('BID_GENERATOR', '‚ùå Bid Generator cannot access test data');
                }
            }, 1000);

        } catch (error) {
            this.logEvent('BID_GENERATOR', `Sync test error: ${error.message}`);
        }
    }

    // Calculate total items across all sources
    calculateTotalItems(scanResults) {
        let total = 0;
        
        if (scanResults.local) {
            const local = JSON.parse(scanResults.local);
            total += local.files?.length || 0;
        }
        
        Object.values(scanResults).forEach(source => {
            if (source && typeof source === 'object' && source.atpItems) {
                total += source.atpItems.length || 0;
            }
        });
        
        return total;
    }

    // Export data flow report
    exportDataFlowReport() {
        const report = `
========================================
DATA FLOW MONITORING REPORT
========================================

Generated: ${new Date().toLocaleString()}
Monitoring Status: ${this.monitoring ? 'Active' : 'Inactive'}

========================================
STATISTICS
========================================
Local Files Scanned: ${this.stats.localScanned}
LocalStorage Records: ${this.stats.localStorageCount}
Firebase Synced: ${this.stats.firebaseSynced}
Bid Generator Ready: ${this.stats.bidGeneratorReady}

========================================
DATA TRANSFER LOG
========================================
${this.transferLog.map(log => 
    `[${log.timestamp}] ${log.source}: ${log.message}`
).join('\n')}

========================================
STORAGE ANALYSIS
========================================
LocalStorage Keys: ${Object.keys(localStorage).filter(key => 
    key.includes('scan') || key.includes('google') || key.includes('bid')
).join(', ')}

Firebase Connection: ${db ? 'Connected' : 'Disconnected'}

========================================
RECOMMENDATIONS
========================================
${this.generateRecommendations()}

========================================
END OF REPORT
========================================
        `;

        // Download the report
        const blob = new Blob([report], { type: 'text/plain' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `data-flow-report-${new Date().toISOString().split('T')[0]}.txt`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);
        
        this.logEvent('SYSTEM', 'Data flow report exported');
        showNotification('üìä Data flow report exported successfully', 'success');
    }

    // Generate recommendations based on current state
    generateRecommendations() {
        const recommendations = [];
        
        if (this.stats.localStorageCount === 0) {
            recommendations.push('‚Ä¢ No data in LocalStorage - Run scans to populate data');
        }
        
        if (this.stats.firebaseSynced === 0) {
            recommendations.push('‚Ä¢ No Firebase sync - Check user PIN and Firebase connection');
        }
        
        if (this.stats.bidGeneratorReady === 0) {
            recommendations.push('‚Ä¢ No data for Bid Generator - Complete scans first');
        }
        
        if (this.stats.localStorageCount > 0 && this.stats.firebaseSynced > 0) {
            recommendations.push('‚úÖ Data flow working correctly - Bid Generator ready');
        }
        
        return recommendations.join('\n') || '‚úÖ All systems operational';
    }
}

// Global data flow monitor instance
let dataFlowMonitor;

// Initialize data flow monitor
function initializeDataFlowMonitor() {
    dataFlowMonitor = new DataFlowMonitor();
    dataFlowMonitor.startMonitoring();
}

// Verification functions for UI buttons
function verifyDataFlow() {
    if (dataFlowMonitor) {
        dataFlowMonitor.verifyDataFlow();
    } else {
        showNotification('‚ùå Data flow monitor not initialized', 'error');
    }
}

function testBidGeneratorSync() {
    if (dataFlowMonitor) {
        dataFlowMonitor.testBidGeneratorSync();
    } else {
        showNotification('‚ùå Data flow monitor not initialized', 'error');
    }
}

function exportDataFlowReport() {
    if (dataFlowMonitor) {
        dataFlowMonitor.exportDataFlowReport();
    } else {
        showNotification('‚ùå Data flow monitor not initialized', 'error');
    }
}

// =====================================================================
// UNIFIED PAGE INITIALIZATION
// =====================================================================
document.addEventListener('DOMContentLoaded', () => {
    console.log('üöÄ Page loaded, initializing...');
    
    // Initialize local scanner
    initializeLocalScanner();
    
    // Initialize data flow monitor
    initializeDataFlowMonitor();
    
    // Check if Google API key is already stored
    if (loadApiKey()) {
        console.log('‚úÖ Google API key found');
        initGoogleApi();
    } else {
        console.log('‚ö†Ô∏è Google API key not found, showing input');
        document.getElementById('apiKeyCard').style.display = 'block';
        document.getElementById('authCard').style.display = 'none';
    }
    
    // Initialize token client for OAuth
    initTokenClient();
    
    // Check for existing authentication
    updateAuthStatus();
    
    // Check for auto mode
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('auto') === 'true') {
        console.log('ü§ñ Auto mode detected, starting automatic scan...');
        setTimeout(autoScanAllSources, 2000);
    }
    
    console.log('‚úÖ Initialization complete');
});
</script>

</body>
</html>
